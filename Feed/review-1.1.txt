ezcFeed
=======

- Why is there a module "name" and a "prefix"? Doesn't one of them last? Would
  make it unembigious.

# Some modules have the same name as RSS/ATOM elements (eg. 'content' module and
  ATOM 'content' property. If we want to access properties and modules the same,
  it will be ambiguous ($feed->content refering to ATOM property or content
  module). So the content module has the 'Content' name and 'content' prefix to
  differentiate this.

- ezcFeed::addModule() -> todo.
- How to add a custom module to ezcFeed?
     * A new module can be defined by creating a class which extends the class
     * {@link ezcFeedModule}, and adding it to the {@link self::$supportedModules}
     * and {@link self::$supportedModulesPrefixes} arrays.
  Is it necessary to extend ezcFeed to do this?

# I did not find a better way to do this (I don't know how to see at runtime which
  modules are defined without hard-coding it in ezcFeed).

  # Use static methods like ezcFeed::registerModule(),
    ezcFeed::unregisterModule(), which add or remove a module.

- Why does ezcFeed have double single/multiple value properties (
  $author[s],...).
- ezcFeed::__get() makes use of isset( $this->$property ), this also returns
  true for real protected/private properties. It should call $this->__isset()
  directly. This is also more efficient.
- ezcFeed::__get() should also better throw an ezcBasePropertyNotFoundException.

# In this case, when parsing a feed you will get an exception if trying to fetch
  $feed->title and the title is missing from the XML document.

  # This exception should be issued in the parser then, not in __get().

- ezcFeed::__isset() behaviour incorrect. We return true if a property exists,
  but is null.
- Why does ezcFeed declare protected attributes and mark them as @ignore? No
  class seems to extend ezcFeed. Declaring this private makes more sense.

# Maybe somebody will want to extend ezcFeed so it would be easier with
  protected instead of private attributes (see also issue tracker for requests
  to change private attributes into protected ones).

  # Then we must declar it like this. If we intend people to extend our
    classes, we mark the properties they might need "protected". If this is
    not the case, we keep them private. That is the sense of these keywords.
    But beware, if we mark the protected, they must be API stable and may not
    change later. Protected and @ignore (even better @access private) should
    only be used, if we extend the classes internally in the component, but do
    not want to expose the affected elements as stable API to others.

- Huge docblock at the beginning of the file is annoying. We should think
  about a way to include docs there.

# I prefer to write longer docblocks to help a bit the people who want to jump
  in without reading the tutorial first or asking on IRC.

  # We should think about outsourcing such huge examples and use the @example
    tag for them. This tag receives an external source file name and puts this
    example in the generated docs. We keep it in the online docs this way and
    make source code browsing more comfortable.

ezcFeedProcessor
================

- Why does ezcFeedProcessor use get()/set() instead of
  __set()/__get()/__isset()?

ezcFeedTools
============

- Should be private. No sense in making such utility classes public if they
  are not of special interesst for foreigners.

# prepareDate() could be useful for some people. But the other functions are
  not so important. I will consider making it private. I wanted to add some
  other functions to this class, related to date formatting for different
  feed types.

  # See discussion on the ML.

- ezcFeedTools::getAttributes() is a duplication of
  DOMElement::getAttribute().

# I must have missed that. I will deprecate the function.

- ezcFeedTools::getAttributes() looks pretty much unnesseccary.
  DOMNode->$attributes can be used instead for iteration,
  DOMElement->getAttribute() for access by name.

# I must have missed that. I will deprecate the function.

- ezcFeedTools::prepareDate() should not accept DateTime objects. If it
  receives them, this indicates bad code.

# What if you assign a DateTime object to $feed->published for example? Should
  the code throw an exception because the date was not a string or timestamp?

  # The exception for assigning DateTime objects should be made in __set().
    This way it is clear, that this is the intended behaviour and that other
    data assigned must be parsed. See discussion on the ML.

- ezcFeedTools::normalizeName() should use isset(). Works here and is faster.

# I will update this.

- The Feed component depends on the XML prefix that is used, but should
  instead rely on the full XML name space instead.

# Done. The getModuleName(), getNamespace() and getNamespacePrefix() functions
  from ezcFeedModule and children were changed to static to allow this (and
  it is more logical to have them static).

General
=======

- A lot of multi-line short descriptions for methods, which do not parse
  properly. The very first line of the doc bloc is the short description, all
  following belong to the long description.

# It seems that phpdoc handles this well now.
