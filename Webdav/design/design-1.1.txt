eZ component: Webdav, Design, 1.1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Author: Tobias Schlitt
:Revision: $Rev$
:Date: $Date$
:Status: Draft

.. contents::

Scope
^^^^^

The scope of this document is to describe the enhancements for the Webdav
component version 1.2.

The general goal for this version is to support locking as described in RFC
2518. To achieve this, the if-header must be parsed and respected by the Webdav
component. This currently is not the case. The if-header must also be used to
respect entity tags, which is not an integral part of the locking feature.
However, the support of entity tags is part of this design, too. 

The following issues are covered in this design:

- Webdav does not provide ETags and does not honor the if-header with them
  (#12583).
- Lock support (#12286).

For locking, a plugin based approach has been favored while the Webav
components was initially design. However, it might turn out that the
realization of lock support through a plugin is not as easy as it seemed to be.
Therefore this document describes a plugin based approach in the first place,
but also contains hints about major differences for an integrated approach.

The document is divided into 3 parts. The first part deals with the realization
of functionality that is exclusively meant to support entity tags. The second
part describes features that are exclusively used to support locking.  Since
WebDAV mixes entity tags (originally HTTP/1.1) and locking in some places, the
third section describes the design for these common concerns.

In several sections of this document so called pseudo code is used, to describe
the functionality of an algorithm. These listings do not follow any specific
syntax or semantic rules, but should be intuitively understandable for people
who know a procedural programming language. Their final implementation in PHP
will require much more code and more complex structures. Beside that,
code-reuse will play a role during implementation.

Entity tag support
^^^^^^^^^^^^^^^^^^

This section describes the support of entity tags in the Webdav component,
including the usage of the If header with entity tags and the generation and
sending of the ETag header. The If header can also be used with lock tokens.
Therefore its general processing is described in the `Common concerns`_
section.

The following design only refers to the support of entity tags as defined in
the HTTP/1.1 RFC. This includes the headers mentioned in the RFC overview
document and the generation and comparison of entity tags.

Entity tag generation
=====================

The generation of an entity tag requires uniqueness for a specific state of a
resource (the so-called entity), To achieve this, multiple data about the
resource state must and be combined.

The path of the resource in combination with its last modification time and
content length should be sufficient. The Lighttpd__ web server makes use of
this information on a configurable basis, too. In addition it can use the inode
of the file for entity tag generation. Since inodes are operating system
dependent and only available for file system based back ends, they will not be
used in our entity tag generation scheme. An MD5 hash will be used to create
the tag from a concatination of previosly named data to ensure common length
and appearance of entity tags.

__ http://www.lighttpd.net/

Since entity tags in WebDAV are also available through the getetag
live-property, a common way is needed to generate the entity tags for the
headers and the property. The ezcWebdavSimpleBackend class will therefore
request the getetag property from the extending back end class and use it's
value for the ETag header and validation of incoming entity tags.

The current generation of entity tags in ezcWebdavFileBackend will be replaced
by a mechanism that uses the last modification time and the size of the file.
This mechanism will be implemented generically in ezcWebdavSimpleBackend to
allow other extending backends to use it.

Header handling
===============

The handling of entity tag related headers must take place in several different
architecture levels of the Webdav component.

Transport layer
---------------

The transport layer needs to be able to parse the request headers and to
serialize the response headers. Therefore the ezcWebdavHeaderHandler class
will be enhanced to do so.

The class must parse the following new request headers to support HTTP/1.1
entity tag usage:

- If-Match
- If-None-Match

ezcWebdavHeaderHandler will automatically check if both of these headers are
set. If this is the case, both headers will be silently discarded. Such a
combination is undefined per RFC and we will ignore it on the transport level
already.

Both headers can contain a list of weak/non-weak entity tags or the "*" value,
to indicate that the resource must simply exists, no matter in which state. To
represent this in PHP, the parsed headers will be represented either as an
array of string values or as the boolean value true. The headers will be parsed
into every request object automatically, if they are set.

.. Note::
   The section `Common concerns`_ defines the realization of the If header,
   which is similar to If-Match and If-None-Match. It could be useful to
   combine their representations in the Webdav infrastructure. A decision on
   this will be made during realization.

The back end layer must take responsibility for interpreting the parsed headers
and their values.

In addition ezcWebdavHeaderHandler must take care of serializing the ETag
header, if this one is present in a response object. Since the ETag header may
only contain the string value of an entity tag this mechanism is already
implemented in the current response processing.

Back end layer
--------------

The interpretation of incoming If-Match and If-None-Match headers must be done
in the back end. The implementation will take place in the
ezcWebdavSimpleBackend class. With every incoming request, no matter which
request method is used, the If-Match and If-None-Match headers will be honored
in the following way (pseudo code): ::

    if ( any precondition for the request fails except for the If-* header )
    {
        return <corresponding error response>;
    }
    if ( If-* header condition is not fulfilled )
    {
        return <error response 412  (Precondition Failed)>;
    }
    process <request> as if no If-* header was set;

Since this behavior will be implemented within the ezcWebdavSimpleBackend
class, it automatically works with all extending back end classes. Back ends
that do not extend ezcWebdavSimpleBackend will have to take care for these
headers on their own.

Lock support
^^^^^^^^^^^^

Locking allows a WebDAV client to gain exclusive access to a resource
(collection or non-collection) to avoid the "lost update problem". 

The WebDAV RFC distinguishes locks by 2 essential properties: The scope of the
lock (shared vs. exclusive) and the type of the lock (write vs. read). Only
write locks are specified by the RFC. Therefore we will only implement write
locks. If read locking becomes necessary sometimes, this can still be added.

A lock is always bound to a principle (not a client!) and one or more
resources. The combination is defined through a unique string named "lock
token". Using an exclusive lock, a principle ensures that he has absolutely
exclusive write access to the locked resource. With a shared lock it is
possible that multiple principles edit one and the same resource. More
information on lock scopes is provided in the corresponding RFC overview
document.

This section describes the realization of lock support through a plugin for
the Webdav component. This plugin will make use of the, not yet officially
released, plugin API. At the end of the section, some paragraphs are dedicated
to an alternatetive implementation approach. This approach integrates completly
with the current implementation of the component and does not abstract the
mechanism.

This designs goal is to build a "lock plugin" that is as far independent from
the other Webdav layers as possibly. This especially means, that the
implementation is independent from the back end. Beside that, the plugin should
provide the largest possible compatibility to clients. However a plugin that
hooks into the parsing process cannot provide the same client compatibility
mechanisms as the base Webdav transport layer.

======
Design
======

In following the main algorithms and functionalities are described that need to
be implemented for a realization of locking. This design does not so much
contain class and interface specifications, because most classes are internally
to the lock plugin. Interaction with other parts of the Webdav component is
realized by attaching to hooks of the plugin architecture or calling public
methods of other components. All classes not defined explictly in this document
will be marked private.

The design description is structured by the changes that affect the 3 layers of
the Webdav component. Mechanisms which are central for the plugin or affect
multiple layers are described in dedicated sections after that.

Transport layer
===============

On the transport layer the plugin needs to hook into the parseUnknownRequest
signal for 2 new request methods. In addition 2 new live properties need to be
parsed, which is realized through the extractUnknwonLiveProperty and
serializeUnknownLiveProperty hooks.

LOCK / UNLOCK
-------------

The LOCK request can not be parsed, yet. The ezcWebdavLockRequest class and
additional content classes already exists (@private) and need to be moved to
the lock plugin directories. To parse the LOCK request, the parseUnknownRequest
hook is used. The generated ezcWebdavLockRequest object is submitted further
on, to be handled on the server layer.

The same applies for the UNLOCK method.

For both requests the corresponding response objects still need to be created
and need to be serialized by the handleUnknownResponse hook. Repsonse objects
will be created as needed during implementation, as they are not very complex.

Properties
----------

The following live properties need to be added:

- lockdiscovery
- supportedlock

For both the property abstraction classes already exist (@private) and just
need to be moved to the lock plugin directories. The parsing and serializing of
these properties needs to be implemented in the plugin. The hooks
extractUnkownLiveProperty and serializeUnknownLiveProperty will be used for this
purpose. This ensures that the properties can also be stored in the back end
properly.

If the lock plugin is switched off after it has been activated and used
once, the specified properties should still work since they are then simply
considered to dead properties.

The creation and removal of these properties is handled by the lock plugin on
the server layer.

Server layer
============

On the server layer, the hooks receivedRequest and generatedResponse will be
used to intercept the necessary requests and responses. These are on the one
hand the LOCK and UNLOCK methods, which are exclusively handled by the lock
plugin. On the other hand most other methods must be intercepted to check for
the effect of locks.

During the processing of requests, communication with the backend is necessary.
This communication will be handled by creating corresponding request objects
and processing the returned response objects. This ensures that only minimal
adjustments to the back end themselves is necessary and that all imaginable
back ends will support locking automatically. On the other side, this raises
complexity and lowers performance of the lock mechanism itself.

To avoid race conditions while the lock plugin and the backend interact, the
lock plugin must get the posibility to lock the backend completly from
concurring requests. To allow this, a new backend interface will be introduced:

::

    interface ezcWebdavBackendLock
    {
        public function lock();
        public function unlock();
    }

These methods must be implemented by the individual backend and simply needs to
ensure that no other request starts processing as long as the lock is active.
Locking will be done in the receivedRequest hook, before the lock plugin will
come into action. After all processing by the plugin and the backend itself is
finished, the unlocking will take place in the generatedResponse hook.

The following sections describe all necessary funcitionality to be implemented,
except the handling of the If header. This is described in the main section
`Common concerns`_.

LOCK
----

Objects of class ezcWebdavLockRequest must be handled completely by the lock
plugin. In case such a request is received, the following operations must be
performed (pseudo code): ::

    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    lock back end;
    
    generate <lock token>;
    
    create propfind request for <request path>;
    // Infinity if no Depth set
    set Depth header of <propfind request> according to <lock request>;
    send <propfind request> to back end;
    
    if ( <requested resource> does not exist )
    {
        if ( If header was set )
        {
            // Refresh without existing lock
            unlock back end;
            return <response 412 Precondition Failed>; 
        }
        create <lock-null resource>;
        assign <lock token> to <lock-null resource>;
    }
    else
    {
        foreach ( <resource> in <returned response> )
        {
            if ( If header is set )
            {
                refresh timeout of <lockdiscovery> property with <lock token>;
            }
            else
            {
                if ( <resource> is locked exclusively )
                {
                    // Needs to include <lockdiscovery> property of requested
                    // resource without the created lock.
                    return <multistatus response 409 Conflict>;
                }
                if ( <resource> is locked shared and <request> is exclusive )
                {
                    // Needs to include <lockdiscovery> property of requested
                    // resource without the created lock.
                    return <multistatus response 409 Conflict>;
                }

                add <lock token> to <lockdiscovery> property;
                add <user name> to <lockdiscovery> property;
                set <timeout> correctly;
                set <depth> to <depth> of <request>;
            }

            create <proppatch request> for <lockdiscovery> property;
            add <proppatch request> to <requests to send>;
        }
    }

    foreach ( <requests to send> as <req> )
    {
        send <req> to back end;
    }

    register <authentication> with <lock token>;
    
    unlock back end;
    
    return <prop lockdiscovery response for requested resource>;

A class ezcWebdavLockResponse needs to be created, which can represent the
corresponding responses. Objects of this class will be processed by the
transport layer hooks of the lock plugin and are therefore private.

UNLOCK
------

The UNLOCK operations request object carries exactly one lock token that
indeicates the lock to be removed. The RFC does not specify, if the request URI
must identify all resources affected by the lock, but we will assume that for
now. The UNLOCK operation must release all locks that are identifie by the
token. If the request URI does not specify the top most affected lock, we would
need to iterate the whole repository to remove the locks.

The following pseudo code describes the operations to be performed by the
plugin: ::
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    lock back end;

    create propfind request for <request path>;
    set Depth header to INFINITY;
    send <propfind request> to back end;
    
    expireLocks( <resources> in <returned responses> );

    foreach ( <resource> in <returned response> )
    {
        if ( <lock token> is assigned to <resource> )
        {
            if ( <resource> is lock null resource> )
            {
                create <delete request> for <resource>;
                add <delete request> to <requests to send>;
            }
            else
            {
                remove <lock token> from <lockdiscovery> property;
                create <proppatch request> for <lockdiscovery> property;
                add <proppatch request> to <requests to send>;
            }
        }
    }

    foreach ( <requests to send> as <req> )
    {
        send <req> to back end;
    }

    unregister <lock token>;
    
    unlock back end;
    
    return <corresponding response>;

If the lock token could not be found in any of the resources returned by the
PROPFIND request we will indicate success to the client. This case might occur,
if the lock expired right before the client sent the request. However, the lock
is gone as desired by the client.

PUT
---

The PUT method requires 2 additional checks in case the If header check
succeeded. The necessary actions to take place before the backend processing
can take place are described a follows (pseudo code): ::

    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    lock back end;
    
    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to back end;

    if ( <resource> exists )
    {
        expireLocks( <resource> );
        if ( <resource> is locked exclusively && !checkIfHeader( <resource> ) )
        {
            return <response 423 Locked>;
        }
        if ( <resource> is a lock null resource )
        {
            create <proppatch request> for <resource> to make it a real resource;
            send <proppatch request> to back end;
        }
    }
    else
    {
        expireLocks( <resource> );
        <parent> = get collection <resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to back end;

        if ( <parent> is locked && !checkIfHeader( <parent> ) )
        {
            return <response 423 Locked>;
        }
    }

    remove If header from <request>;
    // Let back end perform <request> ...

    unlock back end;


POST
----

The POST request is not honored by the Webdav components and will therefore not
be included in lock handling.

PROPPATCH
---------

The necessary extensions to the PROPPATCH method are described below (pseudo
code): ::
    
    lock back end;
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to back end;

    expireLocks( <resource> );

    if ( <resource> is a lock null resource )
    {
        return <response 405 Method Not Allowed>;
    }

    if ( <resource> is locked exclusively && !checkIfHeader( <resource> ) )
    {
        return <response 423 Locked>;
    }

    remove If header from <request>;
    // Let back end perform <request> ...

    unlock back end;

MOVE
----

For the MOVE request 2 different resource trees need to be checked for locks,
before the request handling can take place. The source tree and the destination
collection. The source tree must be checked with infinite depth, while the
destination collection only requires a zero level check. The whole procedure
algorithm is described below (pseudo code): ::
    
    if ( <authentication> invalid )
    {
        return <response 401 Unauthorized>;
    }

    lock back end;
    
    create propfind request for <request resource>;
    set Depth header to INFINITY;
    send <propfind request> to back end;
    
    expireLocks( <resources> in <returned responses> );

    foreach ( <resource> in <returned response> )
    {
        if ( <resource> is locked exclusively && !checkIfHeader( <resource> ) )
        {
            return <response 423 Locked>;
        }
        if ( <resource> is a lock null resource )
        {
            return <response 405 Method not allowed>;
        }
    }
    
    create propfind request for <destination resource>;
    set Depth header to 0;
    send <propfind request> to back end;
    
    expireLocks( <destination resource> );

    if ( <destination resource> exists )
    {
        if ( <destination resource> is locked exclusively && !checkIfHeader( <resource> ) )
        {
            return <response 423 Locked>;
        }
        if ( <destination resource> is a lock null resource )
        {
            delete <destination resource>;
        }
    }
    else
    {
        <parent> = get collection <destination resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to back end;

        if ( <parent> is locked exclusively && !checkIfHeader( <parent> ) )
        {
            return <response 423 Locked>;
        }
    }

    remove If header from <request>;
    // Let back end perform <request> ...

    unlock back end;

.. Note::
   We assume that a lock null resource may deal as the destination for the MOVE
   method. This is not clarified in the RFC.

COPY
----

While only the destination of a COPY method needs to be checked for normal
locks, the source must be checked for lock null resources. Those do not support
the COPY method, so the method must fail, if the tree to copy contains a lock
null resource. Other locks in the source tree do not affect the COPY method,
since read locks are not supported by the Webdav component. The algorithm looks
as follows (pseudo code): ::
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }
    
    lock back end;
    
    create propfind request for <resource>;
    set Depth header to INFINITY;
    send <propfind request> to back end;
    
    foreach ( <resource> in <returned response> )
    {
        if ( <resource> is a lock null resource )
        {
            return <response 405 Method not allowed>;
        }
    }
    
    create propfind request for <destination resource>;
    set Depth header to 0;
    send <propfind request> to back end;
    
    expireLocks( <destination resource> );

    if ( <destination resource> exists )
    {
        if ( <destination resource> is locked exclusively && !checkIfHeader( <destination resource> ) )
        {
            return <response 423 Locked>;
        }
        if ( <destination resource> is a lock null resource )
        {
            delete <destination resource>;
        }
    }
    else
    {
        <parent> = get collection <destination resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to back end;
        
        expireLocks( <parent> );

        if ( <parent> is locked && !checkIfHeader( <parent> ) )
        {
            return <response 423 Locked>;
        }
    }

    remove If header from <request>;
    // Let back end perform <request> ...

    unlock back end;

.. Note::
   We assume that a lock null resource may deal as the destination for the COPY
   method. This is not clarified in the RFC.

DELETE
------

The DELETE method works on collection and non-collection resources and
therefore needs to check infinite depth for locks. Lock null resources do not
support the DELETE action, so the method must fail, if such a resource is to be
deleted. The following pseudo code shows the whole procedure: ::
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }
    
    lock back end;
    
    create propfind request for <resource>;
    set Depth header to INFINITY;
    send <propfind request> to back end;
    
    expireLocks( <resources> in <returned responses> );

    foreach ( <resource> in <returned response> )
    {
        if ( <resource> is locked exclusively && !checkIfHeader( <resource> ) )
        {
            return <response 423 Locked>;
        }
        if ( <resource> is a lock null resource )
        {
            return <response 405 Method Not Allowed>;
        }
    }

    remove If header from <request>;
    // Let back end perform <request> ...

    unlock back end;

MKCOL
-----

The MKCOL method is similar to the PUT request in terms of locking. The
following pseudo code shows what needs to be done: ::

    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }
    lock back end;

    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to back end;

    if ( <resource> exists )
    {
        expireLocks( <resource> );

        if ( <resource> is locked exclusively && !checkIfHeader( <resource> ) )
        {
            return <response 405 method not allowed>;
        }
        if ( <resource> is a lock null resource )
        {
            delete <resource>;
        }
    }
    else
    {
        <parent> = get collection <resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to back end;
        
        expireLocks( <parent> );

        if ( <parent> is locked exclusively && !checkIfHeader( <parent> ) )
        {
            return <response 423 Locked>;
        }
    }

    remove If header from <request>;
    // Let back end perform <request> ...

    unlock back end;

GET / HEAD
----------

The GET and HEAD methods are not directly affected by locks. Since we store
lock-null resources as normal resources and only add custom properties to them
for identification, GET/HEAD requests need to be intercepted. If they are
performed on a lock null resource, the method must fail. The following checks
are therefore needed (pseudo code): ::

    lock back end;

    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to back end;

    expireLocks( <resource> );

    if ( <resource> exists && <resource> is a lock null resource )
    {
        return <405 Method not allowed>;
    }

    unlock back end;

    // Let back end perform request

Authentication
==============

Although a certain lock is uniquely identified by a lock token, this does not
ensure that only the lock holding principle can make use of it. The lock tokens
associated with a certain resource can be obtained by any principle through the
lockdiscovery property.

To ensure that a certain lock token is only used by the principle who created
it, a dedicated authentication mechanism is necessary. Authentication
credentials can only be provided through HTTP-Auth, which is accessible to PHP
applications through $_SERVER['PHP_AUTH_USER'] and $_SERVER['PHP_AUTH_USER'].

To ensure that a principle is generally allowed to perform a certain action at
all and that a specific lock token is valid for a certain principle, an
authentication interface will be provided that can be implemented by a user to
perform custom authentication. Since the Webdav component does not ship with a
dedicated authentication mechanism, the default implementation will always
validate a user as authenticated.

The abstract base class for authentication will look as follows: ::

    abstract class ezcWebdavLockAuthenticationManager
    {
        public function authenticate( $path );

        public function registerLock( $lockToken );
        public function validateLock( $lockToken );
        public function unregisterLock( $lockToken );

        public function getUserName()
        { ... }
        protected function getPassword()
        { ... }
    }

The class implements the methods getUserName() and getPassword() per default
using the HTTP Auth mechanism. This may be overwritten by extended classes
which potentially want to provide other methods than HTTP Auth. The
getUserName() method is public, because the lock plugin will use it to store
the "author" of a lock in the lockdiscovery property. In contrast, the
getPassword() method is protected to ensure that no other object can access the
password.

The method authenticate() retrieves the current user name and password
internally, using the specific methods, and verifies their correctness. The
method receives the current request path in addition, to verify that the
current user is allowed to access the desired path. The \*Lock() methods are
used to manage lock tokens and their assignment to principles. The principle is
to be distinguished by the authentication object through the getUserName()
method.

The registerLock() method assigns a $lockToken to the current principle.
validateLock() validates that the given $lockToken belongs to the
current principle. The unregisterLock() method discards a lock token when the
UNLOCK method is used or in case the lock token expires. The lock plugin will
have called the validateLock() method before this, to ensure that only the
correct principle can lift a lock, if necessary.

.. Note::
   For COPY and MOVE requests authentication has to happen twice: Once for the
   source and once for the destination path.

The basic implementation of this interface, which is shipped with the lock
plugin, is  called ezcWebdavLockFakeAuthenticator. It will not perform any of
the desired checks, but simply return true on all method calls. *This does not
provide any authentication*, but allows the lock plugin to be used in a trusted
environment, where lock tokens are not subject to be exploited. The class will
return the users IP address from the getUserName() method to allow the lock
plugin to set the owner information of the lockdiscovery property properly.  In
this case a principle is equal to a client.

.. Note::
   Usually it is a good idea allow authentication without being specific to
   locking. This would mean to offer an authentication mechanism globally for
   the Webdav component. The problem here is, that this will not easily include
   lock management. In addition, the scope of this feature release would be
   further extended.

Lock null resources
===================

Lock null resources are not yet existing resources which have been already been
locked. The sense behind this is to lock a resource before it is created, to
ensure that no other principle can interfere with this creation. Lock null
resources may not appear as complete resources to the accessing clients, so
that the lock plugin must check under certain circumstances if an affected
resource is a lock null resource or not.

Lock null resources need to be persistent between requests as long as their
lock exists. As soon as this lock is removed or expires the lock null resource
must be removed, too. If the creation process on a lock null resource succeeds
it must be converted into a real resource.

To allow the lock plugin to distinguish between lock null resources and real
resources, a new dead property will be introduced in the dedicated name space
*ezclock*. In this name space the empty property *nullresource* will be used to
indicate that a resource is a lock null resource.

During a request the lock plugin needs to check responses for lock null
resources before they are serialized by the transport. Supported methods of
lock null resources are:

- PUT
- MKCOL
- OPTIONS
- PROPFIND
- LOCK
- UNLOCK

All other methods will return 405 (Method Not Allowed). For the PROPFIND
request, only certain properties are supported by lock null resources. These
are mainly the lockdiscovery and supportedlock properties, All other live
properties should be empty.

.. Note::
   The fact that lock null resource properties are mostly empty is not a MUST
   condition in the RFC, so we will leave most properties as set by the
   back end, to allow proper serialization on the transport layer.

===================
Integrated approach
===================

This section describes a potential realization of locking by integrating the
necessary functionality completely into the Webdav component. The general
algorithms for lock related mechanisms have already been described in detail in
the previous section. They will therefore not be repeated in this section, but
only the implementation differences will be mentioned.

The goal of an integrated approach is to reduce the overhead produced by
locking to a minimum. This is only possible my integrating the lock mechanisms
fully into the current source code. In opposite implementing a plugin, which is
almost completely independent from the current code base.

While the plugin approach described above will perform worse against an
integrated approach, the latter one will raise significantly raise the code
complexity of lock supporting backends and therefore reduce their
maintainability.

Transport layer
===============

The functionality described for the `Plugin base approach`_ need to be included
into the current transport layer. The implementations themselves stay almost
exactly the same. The main change is the place of implementation. Instead of
creating new classes and using the plugin API some new methods in
ezcWebdavTransport and ezcWebdavPropertyHandler will be implemented. The raise
of complexity in these classes is moderate or even low.

The caused advantage is that client specific adjustments will easily be
possible for the parsing and serializing methods of the transport layer.  With
the plugin based approach these adjustments would need to be hard coded into
the plugin source. With the integrated approach, these adjustments can be
handled by class extension and configuration through the ezcWebdavServer class.

Server layer
============

With an integrated approach, no changes on the server layer are necessary. All
changes directly influence the transport and back end layers. Only
`Authentication`_ might be shifted to this layer. An advantage here is, that
global authentication mechanisms can easily be introduced.

Back end layer
==============

The ezcWebdavSimpleBackend performs the largest piece of work in an integrated
approach. This still provides a minimal level of abstraction, but far less than
with the plugin based approach. All back end implementations based on
ezcWebdavSimpleBackend will be locking enabled.

On the other hand this might result in slide BC breaks under certain
circumstances. Those will force users who already implemented a custom back end
to implement additional methods or change signatures of existing once. Since
the chance that anyone already implemented a custom back end is low, this
should be affordable.

The basic algorithms to handle the affected methods are the same as for the
plugin based approach. A problem is, that these (complex) algorithms will be
interwoven with the existing methods, raising their complexity by far.

Requests and responses
----------------------

A major difference against the plugin based approach is, that no additional
request/response handling is necessary. All communication with other back end
mechanisms can take place directly through method calls. In the plugin based
approach for all of the following actions a request-response cycle is necessary:

- fetching properties
- setting/updating/removing properties on 1 resource
- checking if resources exist
- creating/deleting resources

Those actions can be performed with much less overhead directly in the back end.

Locking
-------

Since the back end is taking over the complete work, it might not be necessary
to lock it completely when a request is served. If it is necessary to lock the
backend completely, the lock will last much shorter than with the plugin based
approach. The back end does not need to provide a new method to allow the lock
plugin to completely lock it, since locks are completely handled internally.

Common concerns
^^^^^^^^^^^^^^^

This section describes the design to realize support for the If header, which
is used in WebDAV with combinations of entity tags and lock tokens.

============
Plugin based
============

This section tries to design the honoring of the If header in the Webdav
component using a plugin based approach for lock handling. This works
corresponding to the plugin approach described in `Plugin design draft`_.

It is not possibly to extract all parts of locking support into the lock
plugin, since the If header must be parsed in one go. Since this can also
contain entity tags, which do belong into the main component, it cannot be
parsed exclusively in the lock plugin.

Transport layer
===============

The transport layer needs to parse the If header.

.. Note::
   Since the header can contain entity tags and lock tokens, the parsing needs
   to take place inside ezcWebdavHeaderHandler itself and cannot be part of the
   plugin.
   
The If header is the most complex header that needed to be parsed so far. All
other parsed headers either contained a string value or a simply to process
other scalar value. To encapsulate the If header correctly some new classes
need to be invented which are described in following:

::

    abstract class ezcWebdavIfHeaderList implements ArrayAccess
    {
        protected ezcWebdavIfHeaderListItems[] $items;
    }

    class ezcWebdavIfHeaderTaggedList extends ezcWebdavIfHeaderList
    {

    }

    class ezcWebdavIfHeaderNoTagList extends ezcWebdavIfHeaderList
    {

    }

These classes represent the lists provided in an If header. Both are accessed
through the ArrayAccess interface. The keys used to query the object are
resource paths (not URIs!).

An ezcWebdavIfHeaderList object will return an array of
ezcWebdavIfHeaderListItem objects on read access through ArrayAccess. This
array represents the OR concatenation of the items. The item class realizes the
OR combination and is described further below.

The ezcWebdavIfHeaderTaggedList will return the list items defined for the resource
path given via ArrayAccess and only those for the given path (an empty array of
none were defined for this path. In contrast to that,
ezcWebdavIfHeaderNoTagList will return all list items for *every* resource
path, since the lists applies to all resources.

This way of abstracting tagged lists and no-tag lists allows a unified usage of
both classes in deeper layers of the Webdav component (plugin or back end).

::

    class ezcWebdavIfHeaderListItem
    {
        public function __construct(
            array $lockTokens = array(),
            array $eTags      = array(),
            bool $negated     = false
        );

        property-read array $lockTokens;
        property-read array $eTags;
        property-read bool  $negated;
    }

An instance of this class represents a list item, which can combines several
entity tags ($eTag) and lock tokens ($lockTokens). In addition it can be
defined to be negated ($negated === true). The combination represented by such
an object is a logical AND combination. 

Code examples
-------------

Some small code examples to illustrate the above class design will be shown
here.

::

   COPY /resource1 HTTP/1.1
   Host: www.foo.bar
   Destination: http://www.foo.bar/resource2
   If: <http://www.foo.bar/resource1> (<locktoken:a-write-lock-token>
   [W/"A weak ETag"]) (["strong ETag"])
   <http://www.bar.bar/random>(["another strong ETag"])

This example shows a tagged list in the If header, which will be parsed into an
instance of ezcWebdavIfHeaderTaggedList will be created from it in the
Transport layer. The access to this object in the back end or the lock plugin
will look as follows: ::

    $res1items = $ifHeader['/resource1'];

    $res2items = $ifHeader['/resource2'];

    $randomItems = $ifHeader['/random'];

The $res1items variable will contain an array reflecting the conditions
specified for http://www.foo.bar/resource1. The $res2items variable will
contain an empty array since no conditions were defined for this resource.
While the $randomItems variable should normally not be requested (since the
resource is not affected) it would contain the corresponding list items for the
http://www.bar.bar/random resource.

In contrast, the following request would return an instance of
ezcWebdavIfHeaderNoTagList for the contained If header: ::

   COPY /resource1 HTTP/1.1
   Host: www.foo.bar
   Destination: http://www.foo.bar/resource2
   If: (<locktoken:a-write-lock-token> [W/"A weak ETag"]) (["strong ETag"])
   (["another strong ETag"])

Taking the same accesses to the corresponding $ifHeader variable as shown above
will result in all 3 variables containing the same values: All 3 list items
will be contained, since the If header does not use tagging to specify which
resources are affected by the conditions.

Server layer
============

If the lock plugin is active, it needs to hook into every affected request (see
`Affected base methods`_) and check the If header conditions. The check does
not only affect the checking of lock token conditions, but also the check of
entity tag validation, because both condition types are combinable. The checks are
performed via the receivedRequest hook of the plugin API.

The procedure (in pseudo code) is as follows: ::

    lock back end;
    foreach ( <range of affected resources> as <base resource> )
    {
        create propfind request for <base resource>;
        set request properties to <getetag> and <lockdiscovery>;
        set depth according to incoming request;
        send request to back end;
        foreach ( <resources in response> as <resource> )
        {
            if ( <resource> does not conform to If header )
            {
                return <precondition failed response>;
            }
        }
    }
    discard If header;
    unlock back end;

The If header needs to be discarded after correct validation of all entity
tag/lock token conditions. This avoids that the back end checks for the entity
tag conditions a second time.

.. Note::
   The checking of both (lock token and entity tag) conditions is necessary in
   this case, although it results in a small part of code-duplication.

.. Warning::
   The behaviour shown here does not conform to 100% with the WebDAV RFC,
   which states that the "If header is intended to have similar functionality
   to the If- Match header defined in section 14.25 of [RFC2068]". If this is
   taken literally, the lock plugin would need to check if a request would fail
   without the If header before checking the If header itself. This would
   result in unmanageable overhead and code duplication.

.. Warning::
   Actually the back end would have need to be locked completely, in case an If
   header occurred and was successfully checked by the lock plugin. This complete
   lock must be held until the corresponding response was created by the
   back end. Else there is a race condition in the time frame after the lock
   checking until the back end starts processing. This can lead to extremely
   strange results in high-load environments.

Back end layer
==============

The back end receives the parsed If header as described in the Transport
layer section through the $headers property of the request object. We cannot
enforce the honoring of the If header, so back ends do not necessarily honor
them. However, it should be properly documented that this header exists and is
must be honored if shipped with a request.

If a back end takes care for the header, it may only use the $eTag and $negated
properties and must ignore the $lockTokens property. The latter one is used
exclusively in the lock plugin. In case the lock plugin is active, the back end
should never receive any If header. The If header will then be processed
exclusively by the lock plugin.

If the back end pays attention to the If header, it must honor it for every
request and every resource path that is accessed during execution of the
request. To include the checking of the If header into request processing the
following algorithm must be used (pseudo-code): ::

    lock back end;
    if ( preconditions for request without If header are not fulfilled )
    {
        return <corresponding error response>;
    }
    foreach ( <affected resources> as <resource> )
    {
        if ( If header not fulfilled for <resource> )
        {
            return <precondition failed error response>;
        }
    }
    process request;
    unlock back end;
    return <corresponding response>;


The back end does not need to take care of If headers, if the lock plugin is
installed. In this case, the lock plugin will take over the complete check for
the If headers conditions and remove the header from the request object
afterwards.

Infrastructure
==============

The ezcWebdavRequest class does currently not support the removal of headers as
required by the lock plugin. A method ::
    
    public removeHeader( $headerName )

needs therefore to be added. This method also needs to invalidate the headers
internally in the class, so that a manual revalidation using validateHeaders()
needs to occur. Since the lock plugin will remove the If header before the
request object passes ezcWebdavServer, the headers are validated anyways there.


..
   Local Variables:
   mode: rst
   fill-column: 79
   End: 
   vim: et syn=rst tw=79
