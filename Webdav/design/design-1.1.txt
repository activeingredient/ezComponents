eZ component: Webdav, Design, 1.2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Author: Tobias Schlitt
:Revision: $Rev$
:Date: $Date$
:Status: Draft

.. contents::

Scope
^^^^^

The scope of this document is to describe the enhancements for the Webdav
component version 1.2.

The general goal for this version is to support locking as described in RFC
2518. To achieve this, the if-header must be parsed and respected by the Webdav
component. This currently is not the case. The if-header must also be used to
respect entity tags, which is not an integral part of the locking feature. However,
the support of entity tags is part of this design, too. 

The following issues are covered in this design:

- Webdav does not provide ETags and does not honor the if-header with them
  (#12583).
- Lock support (#12286).

Common concerns
^^^^^^^^^^^^^^^

This section introduces common concerns of the issues covered in this design
document and the features resulting from them. Especially the if-header and its
support in the Webdav component are described.

=========================
Plugin based design draft
=========================

This section tries to design the honoring of the If header in the Webdav
component using a plugin based approach for lock handling. This works
corresponding to the pluin approach described in `Plugin design draft`_.

It is not possibly to exctract all parts of locking support into the lock
plugin, since the If header must be parsed in one go. Since this can also
contain entity tags, which do belong into the main component, it cannot be
parsed exclusively in the lock plugin.

Transport layer
===============

The transport layer needs to parse the If header. Since the header can contain
entity tags and lock tokens, the parsing needs to take place inside
ezcWebdavHeaderHandler itself and cannot be part of the plugin. The If header
is the most complex header that needed to be parsed so far. All other parsed
headers either contained a string value or a simply to process other scalar
value. To encapsulate the If header correctly some new classes need to be
invented which are described in following:

::

    abstract class ezcWebdavIfHeaderList implements ArrayAccess
    {
        protected ezcWebdavIfHeaderListItems[] $items;
    }

    class ezcWebdavIfHeaderTaggedList extends ezcWebdavIfHeaderList
    {

    }

    class ezcWebdavIfHeaderNoTagList extends ezcWebdavIfHeaderList
    {

    }

These classes represent the lists provided in an If header. Both are accessed
through the ArrayAccess interface. The keys used to query the object are
resource pathes (not URIs!).

An ezcWebdavIfHeaderList object will return an array of
ezcWebdavIfHeaderListItem objects on read access through ArrayAccess. This
array represents the OR concatenation of the items. The item class realizes the
OR combination and is described further below.

The ezcWebdavIfHeaderTaggedList will return the list items defined for the resource
path given via ArrayAccess and only those for the given path (an empty array of
none were defined for this path. In contrast to that,
ezcWebdavIfHeaderNoTagList will return all list items for *every* resource
path, since the lists applies to all resources.

This way of abstracting tagged lists and no-tag lists allows a unified usage of
both classes in deeper layers of the Webdav component (plugin or backend).

::

    class ezcWebdavIfHeaderListItem
    {
        public function __construct(
            array $lockTokens = array(),
            array $eTags      = array(),
            bool $negated     = false
        );

        property-read array $lockTokens;
        property-read array $eTags;
        property-read bool  $negated;
    }

An instance of this class represents a list item, which can combines several
entity tags ($eTag) and lock tokens ($lockTokens). In addition it can be
defined to be negated ($negated === true). The combination represented by such
an object is a logical AND combination. 

Code examples
-------------

Some small code examples to illustrate the above class design will be showen
here.

::

   COPY /resource1 HTTP/1.1
   Host: www.foo.bar
   Destination: http://www.foo.bar/resource2
   If: <http://www.foo.bar/resource1> (<locktoken:a-write-lock-token>
   [W/"A weak ETag"]) (["strong ETag"])
   <http://www.bar.bar/random>(["another strong ETag"])

This example shows a tagged list in the If header, which will be parsed into an
instance of ezcWebdavIfHeaderTaggedList will be created from it in the
Transport layer. The access to this object in the backend or the lock plugin
will look as follows: ::

    $res1items = $ifHeader['/resource1'];

    $res2items = $ifHeader['/resource2'];

    $randomItems = $ifHeader['/random'];

The $res1items variable will contain an array reflecting the conditions
specified for http://www.foo.bar/resource1. The $res2items variable will
contain an empty array since no conditions were defined for this resource.
While the $randomItems variable should normally not be requested (since the
resource is not affected) it would contain the corresponding list items for the
http://www.bar.bar/random resource.

In contrast, the following reqeuest would return an instance of
ezcWebdavIfHeaderNoTagList for the contained If header: ::

   COPY /resource1 HTTP/1.1
   Host: www.foo.bar
   Destination: http://www.foo.bar/resource2
   If: (<locktoken:a-write-lock-token> [W/"A weak ETag"]) (["strong ETag"])
   (["another strong ETag"])

Taking the same accesses to the corresponding $ifHeader variable as shown above
will result in all 3 variables containing the same values: All 3 list items
will be contained, since the If header does not use tagging to specify which
resources are affected by the conditions.

Plugin
======

If the lock plugin is active, it needs to hook into every affected request (see
`Affected base methods`_) and check the If header conditions. The check does
not only affect the checking of locktoken conditions, but also the check of
etag validation, because both condition types are combineable.

The procedure (in pseudo code) is as follows: ::

    lock backend;
    foreach ( <range of affected resources> as <basse resource> )
    {
        create propfind request for <base resource>;
        set request properties to <getetag> and <lockdiscovery>;
        set depth according to incoming request;
        send request to backend;
        foreach ( <resources in response> as <resource> )
        {
            if ( <resource> does not conform to If header )
            {
                return <precondition failed response>;
            }
        }
    }
    discard If header;
    unlock backend;

The If header needs to be discarded after correct validation of all entity
tag/lock token conditions. This avoids that the backend checks for the entity
tag conditions a second time.

.. Note::
   The checking of both (lock token and entity tag) conditions is necessary in
   this case, although it results in a small part of code-duplication.

.. Warning::
   The behaviour showen here does not conform to 100% with the WebDAV RFC,
   which states that the "If header is intended to have similar functionality
   to the If- Match header defined in section 14.25 of [RFC2068]". If this is
   taken literally, the lock plugin would need to check if a request would fail
   without the If header before checking the If header itself. This would
   result in unmanageable overhead and code duplication.

.. Warning::
   Actually the backend would have need to be locked completly, in case an If
   header occured and was succesfully checked by the lock plugin. This complete
   lock must be held until the corresponding response was created by the
   backend. Else there is a race condition in the time frame after the lock
   checking until the backend starts processing. This can lead to extremly
   strange results in high-load environments.

Backend layer
=============

The backend receives the parsed If header as described in the Transport
layer section through the $headers property of the request object. We cannot
enforce the honoring of the If header, so back ends do not neccessarily honor
them. However, it should be properly documented that this header exists and is
must be honored if shipped with a request.

If a backend takes care for the header, it may only use the $eTag and $negated
properties and must ignore the $lockTokens property. The latter one is used
exclusively in the lock plugin. In case the lock plugin is active, the back end
should never receive any If header. The If header will then be processed
exclusively by the lock plugin.

If the backend pays attention to the If header, it must honor it for every
request and every resource path that is accessed during execution of the
request. To include the checking of the If header into request processing the
following algorith must be used (pseudo-code): ::

    lock backend;
    if ( preconditions for request without If header are not fulfilled )
    {
        return <corresponding error response>;
    }
    foreach ( <affected resources> as <resource> )
    {
        if ( If header not fulfilled for <resource> )
        {
            return <precondition failed error response>;
        }
    }
    process request;
    unlock backend;
    return <corresponding response>;


The backend does not need to take care of If headers, if the lock plugin is
installed. In this case, the lock plugin will take over the complete check for
the If headers conditions and remove the header from the request object
afterwards.

Infrastructure
==============

The ezcWebdavRequest class does currently not support the removal of headers as
required by the lock plugin. A method ::
    
    public removeHeader( $headerName )

needs therefore to be added. This method also needs to invalidate the headers
internally in the class, so that a manual revalidation using validateHeaders()
needs to occur. Since the lock plugin will remove the If header before the
request object passes ezcWebdavServer, the headers are validated anyways there.


Entity tag support
^^^^^^^^^^^^^^^^^^

This section describes the support of entity tags in the Webdav component, including
the usage of the if-header with entity tags and the generation and sending of the
ETag header.

The following design only refers to the support of entity tags as defined in
the HTTP/1.1 RFC. This includes the headers mentioned in the above RFC overview
and the generation and comparison of entity tags.

Entity tag generation
=====================

The generation of an entity tag requires uniqueness for the state of a resource
(the so-called entity), To achieve this, multiple data of the resource and be
involved and combined.

The last modification time in combination with the file size should be a
sufficient combination of data to generate an entity tag from. The Lighttpd
web server uses this information on a configurable basis, too. In addition it
can use the inode of the file for entity tag generation. Since inodes are
operating system dependent and only available for file system based back ends,
they will not be used in our entity tag generation scheme.

Since entity tags in WebDAV are also available through the getetag
live-property, a common way is needed to generate the entity tags for the
headers and the property. The ezcWebdavSimpleBackend will therefore request the
getetag property from the extending back end and use it's value for the headers
and validation.

The current generation of entity tags in ezcWebdavFileBackend will be replaced
by a mechanism that uses the last modification time and the size of the file.
It currently uses the path, which is not reliable and does not belong into the
entity tag. Entity tags are only valid for a single resource and only in
combination with its URI.

Header handling
===============

The handling of entity tag related headers must take place in several different
architecture levels of the Webdav component.

Transport layer
---------------

The transport layer needs to be able to parse the request headers and to
serialize the response headers back. Therefore the ezcWebdavHeaderHandler class
will be adjusted.

The class must parse the following new request headers:

- If-Match
- If-None-Match

ezcWebdavHeaderHandler will check if both of these headers are set. If this is
the case, both headers will be silently discarded, since such a combination is
undefined.

Both headers can contain a list of weak/non-weak entity tags or the "*" value,
to indicate that the resource must just exists, no matter in which state. To
represent this in PHP, the parsed headers will be represented either as an
array of string values or as the boolean value true. The headers will be parsed
into every request object automatically, if they are set.

The back end layer must take responsibility for interpreting the headers and
their values.

In addition, ezcWebdavHeaderHandler must take care of serializing an ETag
header, if this one is present in a response object. Since the ETag header may
only contain the string value of an entity tag, this mechanism is already
implemented in the response processing.

Back end layer
--------------

The interpretation of incoming If-Match and If-None-Match headers must be done
in the back end. The implementation will take place in the
ezcWebdavSimpleBackend class. With every incoming request, no matter which
request method is used, the If-Match and If-None-Match headers will be honored
in the following way:

If the back end determines that an If-Match header is set, it will:

- Check if all preconditions (except the If-Match) are fulfilled.

  - If not, return a corresponding error response.

- Check if the If-Match value is a boolean true.
  
  - Check if the requested path exists.
  
  - If it *does not*, cancel the method and return 412 (Precondition Failed).

- Check if the If-Match value is an array of strings.
  
  - Retrieve the affected resources getetag property and compare it with all
    strings in the array.
  
  - If *none* matches, cancel the method and return 412 (Precondition Failed).

- Process the method as if the If-Match header was not set.

If the back end determines that an If-None-Match header is set, it will:

- Check if all preconditions (except the If-Match) are fulfilled.
  
  - If not, return a corresponding error response.

- Check if the If-Match value is a boolean true.
  
  - Check if the requested path exists.
    
    - If it *does*, cancel the method and return 412 (Precondition Failed).

- Check if the If-Match value is an array of strings.
  
  - Retrieve the affected resources getetag property and compare it with all
    strings in the array.
    
    - If *any* matches, cancel the method and return 412 (Precondition Failed).

- Process the method as if the If-None-Match header was not set.

Since this behavior will be implemented within the ezcWebdavSimpleBackend
class, it automatically works with all extending back end classes. Back ends
that do not extend ezcWebdavSimpleBackend will have to take care for these
headers on their own.

Lock support
^^^^^^^^^^^^

Locking allows a WebDAV client to gain exclusive access to a resource
(collection or non-collection) to avoid the "lost update problem". This means
that a client can define to have exclusive access to a resource for a certain
time, where no other client may gain access to this resource.

The WebDAV RFC distinguishes locks by 2 essential properties: The scope of the
lock (shared vs. exclusive) and the type of the lock (write vs. read), while
for the type only a write lock is specified. Using an exclusive lock the client
ensures that he has absolutely exclusive access to the locked resource. With a
shared lock it is possible the multiple clients take part in one and the same
lock. More information on lock scopes are provided later.

Locking
^^^^^^^

===================
Plugin design draft
===================

This section describes a potential realization of locking through a plugin for
the Webdav component. This plugin will make use of the, not yet officially
released, plugin API.

Design goals
============

This design drafts goal is to build a lock plugin that is almost completely
independent from the used back end. In this sense, the requirements to be
fulfilled by a back end must be cut down as far as possible. Beside that, the
plugin should provide the largest possible compatibility to clients. However a
plugin that hooks into the parsing process cannot provide the same client
compatibility mechanisms as the base Webdav transport layer.

Hooks
=====

The plugin needs to assign to several hooks offered by the plugin API, which
will be described roughly in this section.

parseUnknownRequest (ezcWebdavTransport)
----------------------------------------

The requests LOCK and UNLOCK are dedicated to the locking mechanism. Therefore
the plugin needs to hook into parseUnknownRequest and parse the incoming
requests into (new) corresponding request objects.



===========
Open issues
===========

Authentication
==============

The problem
-----------

The WebDAV RFC specifies that lock tokens are not secure for authentication
since the can be obtained by every client with access to the repository through
the lockdiscovery property. Therefore, a server must provide its own
authentication scheme. We currently do not support any authentication mechanism
in the Webdav component. To realize locking, we need to support at least 1
authentication model in the component.

Solution attempt
----------------

The only possible authentication scheme provided through the HTTP protocol is
HTTP-Auth. Therefore the HTTP-Auth information should be integrated into every
request object, if provided. To check this information, an interface should be
provided that provides the following capabilities:

- Information of the assignment of a new lock token to a specific HTTP-Auth
  user.
- Removal of a lock token.
- Answer to the question if a certain user may perform an action with a given
  lock token.

In addition we should provide a basic implementation of this class, which does
actually not do anything but discard the given information and return true on
authentication question. This will not provide any security, but allow users to
plug their own authentication mechanisms into the lock facilities.

Further thoughts
----------------

In future it might be possibly that a WebdavAuthenticationTiein is implemented,
which might then be plugged into the described mechanism, too. This could in
addition be used for a "plugin" that performs authentication (and possibly
authorization?) in general on the transport/server level.

Lock null resources
===================

The problem
------------

For our special case this means, that we need to "physically" create
lock-null resources in the utilized back end, to make it persist during
requests, whenever a null-lock is acquired. This lock-null resource must
not appear as a real resource to the client (e.g. must not have a
correct content type and must not respond to GET requests). If the
resource is unlocked again, it must be removed from the back end again.

In our internal handling, that means, that we need to intervene any of
the operations not supported by a lock-null resource (e.g. COPY, MOVE,
PROPPATCH) requests to check is a lock-null resource is affected and
remove it potentially or forbid the operation. Furthermore, we need to
intervene any operation that is supported by a lock-null resource to
remove potential information from responses that must not be available
for lock-null resources. This will mean a lot of internally generated
requests to the back end and a lot of processing of the back end generated
responses.

For example, if a MOVE request is issued by a client, we need to check
the whole affected directory tree for lock-null resources and remove
those from the destination and send a special error code for them in the
response.

Atomicity of operations also comes into play here, since our internal
requests to the back end might interfere with other external requests. For
example, a null-lock might be acquired by the client while we are
internally checking the correctness of a MOVE request (race-condition).

Solution attempts
-----------------

I currently do not see a full solution for this problem, still there are
some ideas in my mind, that might be helpful. For lock-null resources we
can invent a special dead-property name space to indicate such resources.
If a special (for lock-null resources forbidden) operation occurs, we
can easily check for them using a PROPFIND request. Creating and
maintaining lock-null resources should then be not problem.

For the race-condition issue, we'll definitely need support in the
back end, because I see no other solution attempt here to ensure the
consistency.


..
   Local Variables:
   mode: rst
   fill-column: 79
   End: 
   vim: et syn=rst tw=79
