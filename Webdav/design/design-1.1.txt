eZ component: Webdav, Design, 1.1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:Author: Tobias Schlitt
:Revision: $Rev$
:Date: $Date$
:Status: Draft

.. contents::

Scope
^^^^^

The scope of this document is to describe the enhancements for the Webdav
component version 1.2.

The general goal for this version is to support locking as described in RFC
2518. To achieve this, the if-header must be parsed and respected by the Webdav
component. This currently is not the case. The if-header must also be used to
respect entity tags, which is not an integral part of the locking feature.
However, the support of entity tags is part of this design, too. 

The following issues are covered in this design:

- Webdav does not provide ETags and does not honor the if-header with them
  (#12583).
- Lock support (#12286).

For locking, a plugin based approach has been favored while desiging and
creating the Webdav component version 1.0. However, it turned out that the
realization of lock support through a plugin is not as easy as it seemed to be.
Therefore this document describes 2 different design approaches for lock
related functionality: A plugin based one and an integrated one.

The document is devided into 3 parts. The first part deals with the realization
of functionality that is execlusively meant to support entity tags. The second
part describes features that are exclusively used to support locking features.
Since WebDAV mixes entity tags (originally HTTP/1.1) and locking in some
places, the third section describes the design for these common concerns.

Entity tag support
^^^^^^^^^^^^^^^^^^

This section describes the support of entity tags in the Webdav component, including
the usage of the if-header with entity tags and the generation and sending of the
ETag header.

The following design only refers to the support of entity tags as defined in
the HTTP/1.1 RFC. This includes the headers mentioned in the above RFC overview
and the generation and comparison of entity tags.

Entity tag generation
=====================

The generation of an entity tag requires uniqueness for the state of a resource
(the so-called entity), To achieve this, multiple data of the resource and be
involved and combined.

The last modification time in combination with the file size should be a
sufficient combination of data to generate an entity tag from. The Lighttpd
web server uses this information on a configurable basis, too. In addition it
can use the inode of the file for entity tag generation. Since inodes are
operating system dependent and only available for file system based back ends,
they will not be used in our entity tag generation scheme.

Since entity tags in WebDAV are also available through the getetag
live-property, a common way is needed to generate the entity tags for the
headers and the property. The ezcWebdavSimpleBackend will therefore request the
getetag property from the extending back end and use it's value for the headers
and validation.

The current generation of entity tags in ezcWebdavFileBackend will be replaced
by a mechanism that uses the last modification time and the size of the file.
It currently uses the path, which is not reliable and does not belong into the
entity tag. Entity tags are only valid for a single resource and only in
combination with its URI.

Header handling
===============

The handling of entity tag related headers must take place in several different
architecture levels of the Webdav component.

Transport layer
---------------

The transport layer needs to be able to parse the request headers and to
serialize the response headers back. Therefore the ezcWebdavHeaderHandler class
will be adjusted.

The class must parse the following new request headers:

- If-Match
- If-None-Match

ezcWebdavHeaderHandler will check if both of these headers are set. If this is
the case, both headers will be silently discarded, since such a combination is
undefined.

Both headers can contain a list of weak/non-weak entity tags or the "*" value,
to indicate that the resource must just exists, no matter in which state. To
represent this in PHP, the parsed headers will be represented either as an
array of string values or as the boolean value true. The headers will be parsed
into every request object automatically, if they are set.

The back end layer must take responsibility for interpreting the headers and
their values.

In addition, ezcWebdavHeaderHandler must take care of serializing an ETag
header, if this one is present in a response object. Since the ETag header may
only contain the string value of an entity tag, this mechanism is already
implemented in the response processing.

Back end layer
--------------

The interpretation of incoming If-Match and If-None-Match headers must be done
in the back end. The implementation will take place in the
ezcWebdavSimpleBackend class. With every incoming request, no matter which
request method is used, the If-Match and If-None-Match headers will be honored
in the following way:

If the back end determines that an If-* header is set, it will (pseudo
code): ::

    if ( any precondition for the request fails except for the If-* header )
    {
        return <corresponding error response>;
    }
    if ( If-* header condition is not fulfilled )
    {
        return <error response 412  (Precondition Failed)>;
    }
    process <request> as if no If-* header was set;

Since this behavior will be implemented within the ezcWebdavSimpleBackend
class, it automatically works with all extending back end classes. Back ends
that do not extend ezcWebdavSimpleBackend will have to take care for these
headers on their own.

Lock support
^^^^^^^^^^^^

Locking allows a WebDAV client to gain exclusive access to a resource
(collection or non-collection) to avoid the "lost update problem". This means
that a client can define to have exclusive access to a resource for a certain
time, where no other client may gain access to this resource.

The WebDAV RFC distinguishes locks by 2 essential properties: The scope of the
lock (shared vs. exclusive) and the type of the lock (write vs. read), while
for the type only a write lock is specified. Using an exclusive lock the client
ensures that he has absolutely exclusive access to the locked resource. With a
shared lock it is possible the multiple clients take part in one and the same
lock. More information on lock scopes are provided later.

============
Plugin based
============

This section describes a potential realization of locking through a plugin for
the Webdav component. This plugin will make use of the, not yet officially
released, plugin API.

Design goals
============

This design drafts goal is to build a lock plugin that is almost completely
independent from the used back end. In this sense, the requirements to be
fulfilled by a back end must be cut down as far as possible. Beside that, the
plugin should provide the largest possible compatibility to clients. However a
plugin that hooks into the parsing process cannot provide the same client
compatibility mechanisms as the base Webdav transport layer.

Transport layer
===============

On the transport layer, the plugin needs to hook into many existing and 2 new
request methods to alter their behavior. This section only describes the
necessary functionality in the transport layer. Further functionality will be
added on the server layer, see below.

LOCK / UNLOCK
-------------

The LOCK request can not be parsed, yet. The ezcWebdavLockRequest class and
additional content classes already exists (@private) and need to be moved to
the lock plugin directories. To parse the LOCK request, the parseUnknownRequest
hook is used. The generated ezcWebdavLockRequest object is submitted further
on, to be handled on the server layer.

The same applies for the UNLOCK method.

For both requests the corresponding response objects still need to be created
and need to be serialzed by the handleUnknownResponse hook.

Properties
----------

The following live properties need to be added:

- lockdiscovery
- supportedlock

For both the property abstraction classes already exist (@private) and just
need to be moved to the lock plugin diretories. The parsing and serializing of
these properties needs to be implemented in the plugin. The hooks
extractUnkownLiveProperty and serializeUnknownLiveProperty will be used for this
purpose. This ensures that the properties can also be stored in the backend
properly.

.. Note::
   If the lock plugin is switched off later for such a repository, the
   specified properties should still work, since they are then simply
   considered dead properties.

The creation and removal of these properties is handled on the server layer by
the lock plugin.

Server layer
============

On the server layer, the hook receivedRequest will be used to intercept the
necessary requests. These are on the one hand the LOCK and UNLOCK methods,
which are exclusively handled by the lock plugin. On the other hand many other
methods must be intercepted to check for locks taking effect. The following
sections describe all necessary changes except the handling of the If header,
which is described in the main section `Common concerns`_.


.. TODO::
   - Add correct checking for If header below (check complete header and remove
     afterwards).

LOCK
----

Objects of class ezcWebdavLockRequest must be handled completly by the lock
plugin. In case such a request is received, the following operations must be
performed (pseudo code): ::

    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    lock backend;
    
    generate <lock token>;
    
    create propfind request for <request path>;
    set Depth header of <propfind request> according to <lock request>;
    send <propfind request> to backend;
    
    if ( <requested resource> does not exist )
    {
        if ( If header was set )
        {
            // Refresh without existing lock
            unlock backend;
            return <response 412 Precondition Failed>; 
        }
        create <lock-null resource>;
        assign <lock token> to <lock-null resource>;
    }
    else
    {
        foreach ( <resource> in <returned response> )
        {
            if ( If header is set )
            {
                refresh timeout of <lockdiscovery> property with <lock token>;
            }
            else
            {
                if ( <resource> is locked exclusively )
                {
                    return <response 423 Locked>;
                }
                if ( <resource> is locked shared and <request> is exclusive )
                {
                    return <response 412 Precondition Failed>;
                }

                add <lock token> to <lockdiscovery> property;
                add <user name> to <lockdiscovery> property;
                set <timeout> correctly;
                set <depth> to <depth> of <request>;
            }

            create <proppatch request> for <lockdiscovery> property;
            add <proppatch request> to <requests to send>;
        }
    }

    foreach ( <requests to send> as <req> )
    {
        send <req> to backend;
    }

    register <authentication> with <lock token>;
    
    unlock backend;
    
    return <prop lockdiscovery response>;

.. Note::
   The code shown above does not include the handling of refreshing LOCK
   requests to reduce complexity. In case of a refresh, the lock token is
   already present in the request (If header) and the timeouts just need to be
   updated.

The realization of the LOCK request via a plugin inquires several requests that
need to be created by the plugin and to be processed by the backend. In
addition, the plugin needs to process the returned response objects.

UNLOCK
------

The unlock operation contains exactly 1 lock token that is to be removed from
the resource(s) identified by the reqeust path. The following pseudo code
describes the operations to be used in the plugin to realize this: ::
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    lock backend;

    create propfind request for <request path>;
    set Depth header to INFINITY;
    send <propfind request> to backend;

    foreach ( <resource> in <returned response> )
    {
        if ( <resource> is lock null resource> )
        {
            create delete request for <resource>;
            send delete request to backend;
        }
        else if ( <lock token> is assigned to <resource> )
        {
            remove <lock token> from <lockdiscovery> property;
            create <proppatch request> for <lockdiscovery> property;
            add <proppatch request> to <requests to send>;
        }
    }

    foreach ( <requests to send> as <req> )
    {
        send <req> to backend;
    }

    unregister <lock token>;
    
    unlock backend;
    
    return <corresponding response>;

If the lock token could not be found in any of the resources returned by the
PROPFIND request, it is save to indicate success to the client. This case might
occur, if the lock expired right before the client sent the request. Anyway,
the lock is gone, as desired by the client.

PUT
---

The PUT method requires 2 additional checks if the If header check succeeded
(meaning that any send If header mached). The actions to take place before the
original processing of the PUT method can take place are described a follows
(pseudo code): ::

    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    lock backend;
    
    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to backend;

    if ( <resource> exists )
    {
        if ( <resource> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
        if ( <resource> is a lock null resource )
        {
            create <proppatch request> for <resource> to make it a real resource;
            send <proppatch request> to backend;
        }
    }
    else
    {
        <parent> = get collection <resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to backend;

        if ( <parent> is locked && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
    }

    // Let backend perform PUT ...

    unlock backend;


POST
----

The POST request is not honored by the Webdav components and will therefore not
be included in lock handling.

PROPPATCH
---------

The PROPPATCH request is only allowed if the affected resource is not locked by
someone else. The necessery extensions are described below (pseudo code): ::
    
    lock backend;
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }

    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to backend;

    if ( <resource> is a lock null resource )
    {
        return <response 405 Method Not Allowed>;
    }

    if ( <resource> is locked exclusively && <lock> is not mentioned in the If header )
    {
        return <response 423 Locked>;
    }

    // Let backend perform PROPPATCH ...

    unlock backend;

MOVE
----

For the MOVE request 2 different resource trees need to be checked for locks.
The algorithm to do so is described below (pseudo code): ::
    
    if ( <authentication> invalid )
    {
        return <response 401 Unauthorized>;
    }

    lock backend;
    
    create propfind request for <request resource>;
    set Depth header to INFINITY;
    send <propfind request> to backend;

    foreach ( <resource> in <returned response> )
    {
        if ( <resource> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
    }
    
    create propfind request for <destination resource>;
    set Depth header to 0;
    send <propfind request> to backend;

    if ( <destination resource> exists )
    {
        if ( <destination resource> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
        if ( <destination resource> is a lock null resource )
        {
            delete <destination resource>;
        }
    }
    else
    {
        <parent> = get collection <destination resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to backend;

        if ( <parent> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
    }

    // Let backend perform MOVE ...

    unlock backend;

COPY
----

In contrast to the MOVE request, only the destination needs to be checked for
locks before copying. The algorithm looks as follows (pseudo code): ::
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }
    
    lock backend;
    
    create propfind request for <destination resource>;
    set Depth header to 0;
    send <propfind request> to backend;

    if ( <destination resource> exists )
    {
        if ( <destination resource> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
        if ( <destination resource> is a lock null resource )
        {
            delete <destination resource>;
        }
    }
    else
    {
        <parent> = get collection <destination resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to backend;

        if ( <parent> is locked && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
    }

    // Let backend perform COPY ...

    unlock backend;

DELETE
------

The DELETE method works on collection and non-collection resources and
therefore needs to check infinite depth for locks (pseudo code): ::
    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }
    
    lock backend;
    
    create propfind request for <resource>;
    set Depth header to INFINITY;
    send <propfind request> to backend;

    foreach ( <resource> in <returned response> )
    {
        if ( <resource> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
        if ( <resource> is a lock null resource )
        {
            return <response 405 Method Not Allowed>;
        }
    }

    // Let backend perform DELETE ...

    unlock backend;

MKCOL
-----

The MKCOL method is similar to the PUT request in terms of locking. The
following pseudo code shows how this works: ::

    
    if ( !authenticate() )
    {
        return <response 401 Unauthorized>;
    }
    lock backend;

    create propfind request for <resource>;
    set Depth header to 0;
    send <propfind request> to backend;

    if ( <resource> exists )
    {
        if ( <resource> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 405 method not allowed>;
        }
        if ( <resource> is a lock null resource )
        {
            delete <resource>;
        }
    }
    else
    {
        <parent> = get collection <resource>;
        create propfind request for <parent>;
        set Depth header to 0;
        send <propfind request> to backend;

        if ( <parent> is locked exclusively && <lock> is not mentioned in the If header )
        {
            return <response 423 Locked>;
        }
    }

    // Let backend perform MKCOL ...

    unlock backend;
    
Authentication
==============

Although a certain lock is uniquely identified by a lock token, this does not
ensure that only the lock holding principle can make use of it. The lock tokens
associated with a certain resoure can be looked up by every principle through
the lockdiscovery property.

To ensure that a certain lock token is only used by the principle who created
it, a dedicated authentication mechanism is necessary. Authentication
credentials can only be provided through HTTP-Auth, which is accessible to PHP
applications through $_SERVER['PHP_AUTH_USER'] and $_SERVER['PHP_AUTH_USER'].

To ensure that a principle is generally allowed to perform a certain action at
all and that a specific lock token is valid for a certain principle, an
authentication interface will be provided that can be implemented by a user to
perform custom authentication. Since the Webdav component does not ship with a
dedicated authentication mechanism, the default implementation will always
validate a user as authenticated.

The abstract base class for authentication will look as follows: ::

    abstract class ezcWebdavLockAuthenticationManager
    {
        public function authenticate( $path );

        public function registerLock( $lockToken, $user );
        public function validateLock( $lockToken, $user );
        public function unregisterLock( $lockToken );

        public function getUserName()
        { ... }
        protected function getPassword()
        { ... }
    }

The class implements the methods getUserName() and getPassword() per default
using the HTTP Auth mechanism. This may be overwritten my extended classes,
that potentiall want to provide different authentication methods than HTTP
Auth. The getUserName() method is public, because the lock plugin will use it
to store the author of a lock token in the lockdiscovery property. In contrast
the getPassword() method is protected, to ensure that nobody can access this
externally.

The method authenticate() retrieves the current username and password
internally and verifies their correctness. The \*Lock() methods are used to
manage lock tokens and their assignement to principles. The given $user
parameter is distinguished by the lock plugin through the getUserName() method.

The registerLock() method assigns a $lockToken to the principle identified by
$user. validateLock() validates that the given lock token belongs to the
current principle. The unregisterLock() method discards a lock token when the
UNLOCK method is used or in case the lock token expires. The lock plugin will
have taken care for validtion before, if necessary.

.. Note::
   For COPY and MOVE requests authentication has to happen twice: Once for the
   source and once for the destination path.

The basic implementation of this interface, called
ezcWebdavLockFakeAuthenticator, will not perform any of the desired checks, but
simply return true on all method calls. *This does not provide any
authentication*, but allows the lock plugin to be used in a trusted
environment, where lock tokens are not subject to be exploited. The class will
return the users IP address from the getUserName() method to allow the lock
plugin to set the owner information of the lockdiscovery property properly.

.. Warning::
   Usually it is a good idea allow authentication without being specific to
   locking. This would mean to offer an authentication mechanism globally for
   the Webdav component. The problem here is, that this will not include lock
   management and for the lock plugin a second authentication point needs to be
   established.

Lock null resources
===================

Lock null resources are not (yet) existing resources, which have been locked.
It makes sense to lock a resource before it is created, to ensure that no other
principle can interfer with the creation. Lock null resources may not appear as
complete resources, so that the lock plugin must check under certain
circumstances if an affected resource is a lock null resource or not.

Lock null resources need to be persistent between requests as long as the lock
that affects them exists. As soon as this lock is removed or expires, the lock
null resource must be removed, too. When a lock null resource is correctly
created, by the principle that holds the lock, it must be converted into a real
resource.

To allow the lock plugin to distinguish between lock null resources and real
resources, a new property namespace is introduced, which is exclusively used in
the lock plugin: *ezclock*. In this namespace, the property *nullresource* will
be used to indicate that a resource is a lock null resource. The property will
contain no content, since its only sense is to indicate that a resource is not
a usual resource.

During each affected request, the lock plugin needs to check responses for lock
null resources before they are serialized by the transport. Supported methods
of lock null resources are:

- PUT
- MKCOL
- OPTIONS
- PROPFIND
- LOCK
- UNLOCK

All other methods will return 405 (Method Not Allowed). For the PROPFIND
request, only certain properties are supported by lock null resources. These
are the lockdiscovery and supportedlock properties, All other live properties
should be empty.

.. Note::
   The fact that lock null resource properties are mostly empty is not a MUST
   condition in the RFC, so we will leave most properties as set by the
   backend, to allow proper serialization on the transport layer.

Common concerns
^^^^^^^^^^^^^^^

This section describes the design to realize support for the If header, which
is used in WebDAV with combinations of entity tags and lock tokens.

============
Plugin based
============

This section tries to design the honoring of the If header in the Webdav
component using a plugin based approach for lock handling. This works
corresponding to the pluin approach described in `Plugin design draft`_.

It is not possibly to exctract all parts of locking support into the lock
plugin, since the If header must be parsed in one go. Since this can also
contain entity tags, which do belong into the main component, it cannot be
parsed exclusively in the lock plugin.

Transport layer
===============

The transport layer needs to parse the If header.

.. Note::
   Since the header can contain entity tags and lock tokens, the parsing needs
   to take place inside ezcWebdavHeaderHandler itself and cannot be part of the
   plugin.
   
The If header is the most complex header that needed to be parsed so far. All
other parsed headers either contained a string value or a simply to process
other scalar value. To encapsulate the If header correctly some new classes
need to be invented which are described in following:

::

    abstract class ezcWebdavIfHeaderList implements ArrayAccess
    {
        protected ezcWebdavIfHeaderListItems[] $items;
    }

    class ezcWebdavIfHeaderTaggedList extends ezcWebdavIfHeaderList
    {

    }

    class ezcWebdavIfHeaderNoTagList extends ezcWebdavIfHeaderList
    {

    }

These classes represent the lists provided in an If header. Both are accessed
through the ArrayAccess interface. The keys used to query the object are
resource pathes (not URIs!).

An ezcWebdavIfHeaderList object will return an array of
ezcWebdavIfHeaderListItem objects on read access through ArrayAccess. This
array represents the OR concatenation of the items. The item class realizes the
OR combination and is described further below.

The ezcWebdavIfHeaderTaggedList will return the list items defined for the resource
path given via ArrayAccess and only those for the given path (an empty array of
none were defined for this path. In contrast to that,
ezcWebdavIfHeaderNoTagList will return all list items for *every* resource
path, since the lists applies to all resources.

This way of abstracting tagged lists and no-tag lists allows a unified usage of
both classes in deeper layers of the Webdav component (plugin or backend).

::

    class ezcWebdavIfHeaderListItem
    {
        public function __construct(
            array $lockTokens = array(),
            array $eTags      = array(),
            bool $negated     = false
        );

        property-read array $lockTokens;
        property-read array $eTags;
        property-read bool  $negated;
    }

An instance of this class represents a list item, which can combines several
entity tags ($eTag) and lock tokens ($lockTokens). In addition it can be
defined to be negated ($negated === true). The combination represented by such
an object is a logical AND combination. 

Code examples
-------------

Some small code examples to illustrate the above class design will be showen
here.

::

   COPY /resource1 HTTP/1.1
   Host: www.foo.bar
   Destination: http://www.foo.bar/resource2
   If: <http://www.foo.bar/resource1> (<locktoken:a-write-lock-token>
   [W/"A weak ETag"]) (["strong ETag"])
   <http://www.bar.bar/random>(["another strong ETag"])

This example shows a tagged list in the If header, which will be parsed into an
instance of ezcWebdavIfHeaderTaggedList will be created from it in the
Transport layer. The access to this object in the backend or the lock plugin
will look as follows: ::

    $res1items = $ifHeader['/resource1'];

    $res2items = $ifHeader['/resource2'];

    $randomItems = $ifHeader['/random'];

The $res1items variable will contain an array reflecting the conditions
specified for http://www.foo.bar/resource1. The $res2items variable will
contain an empty array since no conditions were defined for this resource.
While the $randomItems variable should normally not be requested (since the
resource is not affected) it would contain the corresponding list items for the
http://www.bar.bar/random resource.

In contrast, the following reqeuest would return an instance of
ezcWebdavIfHeaderNoTagList for the contained If header: ::

   COPY /resource1 HTTP/1.1
   Host: www.foo.bar
   Destination: http://www.foo.bar/resource2
   If: (<locktoken:a-write-lock-token> [W/"A weak ETag"]) (["strong ETag"])
   (["another strong ETag"])

Taking the same accesses to the corresponding $ifHeader variable as shown above
will result in all 3 variables containing the same values: All 3 list items
will be contained, since the If header does not use tagging to specify which
resources are affected by the conditions.

Server layer
============

If the lock plugin is active, it needs to hook into every affected request (see
`Affected base methods`_) and check the If header conditions. The check does
not only affect the checking of locktoken conditions, but also the check of
etag validation, because both condition types are combineable. The checks are
performed via the receivedRequest hook of the plugin API.

The procedure (in pseudo code) is as follows: ::

    lock backend;
    foreach ( <range of affected resources> as <basse resource> )
    {
        create propfind request for <base resource>;
        set request properties to <getetag> and <lockdiscovery>;
        set depth according to incoming request;
        send request to backend;
        foreach ( <resources in response> as <resource> )
        {
            if ( <resource> does not conform to If header )
            {
                return <precondition failed response>;
            }
        }
    }
    discard If header;
    unlock backend;

The If header needs to be discarded after correct validation of all entity
tag/lock token conditions. This avoids that the backend checks for the entity
tag conditions a second time.

.. Note::
   The checking of both (lock token and entity tag) conditions is necessary in
   this case, although it results in a small part of code-duplication.

.. Warning::
   The behaviour showen here does not conform to 100% with the WebDAV RFC,
   which states that the "If header is intended to have similar functionality
   to the If- Match header defined in section 14.25 of [RFC2068]". If this is
   taken literally, the lock plugin would need to check if a request would fail
   without the If header before checking the If header itself. This would
   result in unmanageable overhead and code duplication.

.. Warning::
   Actually the backend would have need to be locked completly, in case an If
   header occured and was succesfully checked by the lock plugin. This complete
   lock must be held until the corresponding response was created by the
   backend. Else there is a race condition in the time frame after the lock
   checking until the backend starts processing. This can lead to extremly
   strange results in high-load environments.

Backend layer
=============

The backend receives the parsed If header as described in the Transport
layer section through the $headers property of the request object. We cannot
enforce the honoring of the If header, so back ends do not neccessarily honor
them. However, it should be properly documented that this header exists and is
must be honored if shipped with a request.

If a backend takes care for the header, it may only use the $eTag and $negated
properties and must ignore the $lockTokens property. The latter one is used
exclusively in the lock plugin. In case the lock plugin is active, the back end
should never receive any If header. The If header will then be processed
exclusively by the lock plugin.

If the backend pays attention to the If header, it must honor it for every
request and every resource path that is accessed during execution of the
request. To include the checking of the If header into request processing the
following algorith must be used (pseudo-code): ::

    lock backend;
    if ( preconditions for request without If header are not fulfilled )
    {
        return <corresponding error response>;
    }
    foreach ( <affected resources> as <resource> )
    {
        if ( If header not fulfilled for <resource> )
        {
            return <precondition failed error response>;
        }
    }
    process request;
    unlock backend;
    return <corresponding response>;


The backend does not need to take care of If headers, if the lock plugin is
installed. In this case, the lock plugin will take over the complete check for
the If headers conditions and remove the header from the request object
afterwards.

Infrastructure
==============

The ezcWebdavRequest class does currently not support the removal of headers as
required by the lock plugin. A method ::
    
    public removeHeader( $headerName )

needs therefore to be added. This method also needs to invalidate the headers
internally in the class, so that a manual revalidation using validateHeaders()
needs to occur. Since the lock plugin will remove the If header before the
request object passes ezcWebdavServer, the headers are validated anyways there.




..
   Local Variables:
   mode: rst
   fill-column: 79
   End: 
   vim: et syn=rst tw=79
