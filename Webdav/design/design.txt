eZ component: Webdav, Design, 1.0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:Author: Kore Nordmann, Tobias Schlitt
:Revision: $Rev$
:Date: $Date$
:Status: Draft

.. contents::

Scope
=====

The scope of this document is to describe the initial design of a component
that provides a WebDAV server, which works with all major other implementations
of the WebDAV_ protocol.

.. _WebDAV_: http://en.wikipedia.org/wiki/WebDAV

It is currently not planned to also offer a WebDAV client component.

Design overview
===============

Because of the variaty of buggy and incomplete implementations of WebDAV, this
component will provide an abstraction to suite the different needs. Beside
that, an abstract interface to the backend will be provided.

The main class of this component will provide a fully `RFC 2518`_ compliant
implementation of a WebDAV_ server. An instance of this class retrieves an
instance of a handler class, which takes care for performing the requested
operations on a backend (for example the filesystem).

.. _`RFC 2518`: http://tools.ietf.org/html/rfc2518

Additionally, a collection of classes, which inherit the main class will be
provided. Each of this classes will provide a compatibility layer on top of the
RFC implementation, which works correctly with one or more "buggy" WebDAV
clients. A factory pattern implementation will be provided, which takes
automatically care of creating the correct server instance for a client.

Tiers
=====

The component is basically devided into 3 tiers: The top tier, being
represented by the main server class. An instance of this class is responsible
to dispatch a received request to a correct transport handler, which is capable
of parsing the request.

The transport handler level is the second tier. Classes in this tier are
responsible to parse an incoming request and extract all relevant information
to generate a response for it into a struct object. These struct object is then
passed back to the server object.

Based on the request struct object, the server checks the capabilities of its
third tier, the used backend handler. If the handler object provides all
necessary capabilities to generate a response, it is called to do so. If the
server class can perform emulation of not available capabilities and rely on
different features of the backend. In case there is no way, the backend can
handle the request, the server class will indicate that with an error
response.

The way back flows through the 3 tiers back again: The backend handler
generates a response object, which is passed back to the main server object,
which makes the active transport handler encode the response and sends it back
to the client.

Classes
=======

ezcWebdavServer
---------------

The ezcWebdavServer class is the main class of the package. It has to be
instantiated to create a server instance and provides a method to get the
server up and running. An object of this class takes the main controll over
serving the webdav service.

Among the configuration of the server instance there must be: A backend handler
object, which will be used to serve the received WebDAV requests. A fitting
configuration for the backend handler. A collection of transport handlers which
can be used to parse incoming requests. General configuration on the bevahiour
of the server instance (like locking and stuff).

The backend handler object must extend the base class ezcWebdavBackendHandler
and must indicate to the main server, which capabilities it provides. The
server class can potentially emulate certain capabilities, if the handler does
not provide it. An example here is locking, which can be either performed by
the handler itself or the main server class.

Such emulation functionality could possibly be extracted to a third category of
classes, which is only loaded by the main server object on-demand.

All configured transport handlers must implement the interface
ezcWebdavTransportHandler, which defines the necessary methods.

The standard webdav server contains a list of transport handlers associated
with regular expressions which should match the client name to be used. As a
fallback the standards compliant transport handler will be used.

Special implementation added by the user will be add on top of the list, to be
used at highest priority.

ezcWebdavBackend
----------------

All backend handlers for the Webdav component must extends this abstract base
class and implement its abstract methods for very basic WebDAV serving. The
operations defined for every backend handler to be mandatory are:

- head()
- get()
- propFind()
- propFetch()

All other WebDAV operations are optional to be implemented by a backend handler
and are defined by the handler itself. The additional basic capabilities of
backend handlers are indicated by implementing interfaces for the support
additional request methods, like put, change, etc.

Additional features, like encryption support will be indicated by returning a
bitmask of supported features by the backend handler.

The logical groups of capabilities are:

Put
  The put capability indicates, that a handler is capable of handling file
  uploads via HTTP-PUT method.
Change
  This sub class of WebDAV operations defines delete, copy and move operations to
  be supported by the handler class.
Make collection
  The creation of new collections also makes up a capability unit and can
  optionally be implemented.
Lock
  If the hander provides locking facilities on its own, the main server object
  must not take care about that.
GZIP-Compress
  Handlers implementing this facility can deal with GZIP and bzip2 based
  compression.

If a handler does not support a certain facility and the main server object is
not capable of emulating it, the server will respond using a "501 Not
Implemented" server error.

ezcWebdavTransport
------------------

A class implementing this interface is capable of parsing a raw HTTP request
into a struct extending ezcWebdavRequest and generating the HTTP response out
of the ezcWebdavResponse struct. One transport handler is usually built to
handle the communication with a certain set of specific client
implementations.

A transport handler class will be able to parse the incoming HTTP request data
into a struct identifying a certain type of request and containg all necessary
and unified data, so that a backend handler can repsond to it.

The backend handler will then create a corresponding response object, which
will be encoded back into HTTP data by the transport handler and send to the
client by the server.

Each request type will come with its own struct classes to represent request
and response data for the request. Beside the structured HTTP data, the structs
can contain any additional information that must be transferred between server,
transport handler and backend handler.

All struct classes representing either a request of response of the server will
extend the abstract base classes ezcWebdavRequest and ezcWebdavResponse.

An example of this structure is: ezcWebdavGetRequest and ezcWebdavGetResponse

These 2 classes will be used to serve GET requests. Beside the usual request
information - like URI, date and headers - the request object will contain
information about partial GET mechanisms to use and what else is important.
The backend handler will return an instance of ezcWebdavGetResponse if the
request was handled correctly, or a corresponding ezcWebdavErrorResponse
object, if the request failed.

The main server instance will know about available clients and will have a
regular expression for each of them, to identify the clients it communicates
to by matching the regualr expression against the client name provided in the
HTTP headers.

ezcWebdavPathFactory
--------------------

This class is meant to calculate the path of the requested item from the
backend based on the given path by the webdav client. The resulting path
string is absolute to the root of the backend repository.

This class is necessary to calculate the correct path when a server uses
rewrite rules for mapping directories to one or more webdav implementations.
The basic class uses pathinfo to parse the requested file / collection.

Request:   /path/to/webdav.php/path/to/file
Result:    /path/to/file

You may want to provide custome implementations for different mappings so that
rewrite could be used by the webserver to access files.

Request:   /images/path/to/file
Rewritten: /path/to/dav_images.php/path/to/file
Result:    /path/to/file

The factory class is necessary, because the paths contained in the request
body will match the same scheme like the original request path, but not be
rewritten by the webserver, so that the user may extend the path factory to
fit his own purposes.

Example code
============

The following snippet shows the API calls necessary to get a WebDAV server up
and running.

::

	<?php

	$server = new ezcWebdavServer();

	// Server data using file backend with data in "path/"
	$server->backend = new ezcWebdavBackendFile( '/path' );

    // Optionally register aditional transport handlers
	//
	// This step is only required, when a user wants to provide own
	// implementations for special clients.
	$server->registerTransportHandler(
		// Regular expression to match client name
		'(Microsoft.*Webdav\s+XP)i',
		// Class name of transport handler, extending ezcWebdavTransportHandler
		'ezcWebdavMicrosoftTransport'
	);
	$server->registerTransportHandler(
		// Regular expression to match client name
		'(.*Firefox.*)i',
		// Class name of transport handler, extending ezcWebdavTransportHandler
		'ezcWebdavMozillaTransport'
	);

	// Serve requests
	$server->handle();

Extensibility
=============

A server implementation of the WebDAV protocol needs several levels of
extensibility. 2 ways are already reflected by the fact that the transport
class can be extended to resolve client incompatibilities and the mechanism of
backend handlers, which represent the storage of the server.

2 other areas are significant here:

1. There are several RCFs extending the WebDAV RFC with additional
   functionality, like versioning support.
2. The WebDAV RFC explicitly allows to implement custom extensions by using a
   different namespace in the WebDAV XML communication.

Both areas require us to implement a plugin system that allows custom
extensions. This will also allow us to implement additional information (like
additional RFCs) as tiein components to the base WebDAV server.

The major problem with a plugin system for the Webdav component is, that an
extension might propably want to hook into several places of the component at
once. A developer will want to install several extension packages at once and
use them in paralell. To reflect these issues, the design of a neat plugin
system is required

The plugin system
-----------------

The plugin system must reflect that different areas of the Webdav component
provide completly different types of hooks. Therefore, the definition what a
hook is, should be given first:

A hook is a place in the system, where it will inform external systems, that
this point has been reached. The external systems that are registered with the
hook will receive a set of well-defined parameters for information extraction
and possibly careful manipulation. Where exactly these points are and what the
provided parameters are, is defined by the layer of the Webdav component.

Extension packages are encouraged to not manipulate the provided data in
sensible ways, that might affect the work of 3rd party extensions or possibly
even the server itself. This is a sensible way of introducing code into the
server and must be expressed in the documentation.

Another aspect of the is the extension of all data classes (namely request,
response and property classes) will be extended to be able to carry additional
information in special containers. This will allow an extension package to
attach information to these objects and take care of them in other places.

The 3 different layers of the system will provide the following hooks:

Transport
#########

The Transport layer has a very limited and fixed public API, which is used by
the Server for communication. Since this API is completly fixed, it would not
make sense to provide any hooks here. The internal structure of the transport
classes offers much more sensible places.

The first area of work of the Transport is the parsing of requests, which is
structured by 1 protected method in the class that is assigned to 1 HTTP
request method. While these methods may differ per client, it makes sense to
offer hooks before and after each of them, as well as for new request methods.

While the "before" and "after" hooks for the parsing methods can accept any
number of assigned hook methods, given those a processed in no defined order,
the latter hook may only accept a single method. The global system must offer a
way for extension packages to ask if a hook is already assigned. If a new HTTP
method hook is assigned, its "before" and "after" hooks must be assignable, too
and extensions must detect this.

The second area to provide hooks for is the serialization of resposes. The
requirements here are similar to those of the request parsing, because
dispatching is made by response class. Hooks "before" and "after" each
exsisting response class must be provided, as well as hooks for new ones.

The third area, which plays a bit into the first both, is the handling of
properties. In a lot of extension cases it might only be necessary to hook into
this and to add new live properties or pre-/post-process their custom dead
properties. Therefore hooks for the parsing and serializing of these will be
offered.

A transport hook is always valid for any client and the extension needs to take
care about its behaviour against clients on its own.

Server
######

The servers tasks are defined to be the dispatching of a correct transport
class. Creating a transport object as configured and making this parse the
request into a request object. Hand this over to the configured backend for
processing. Receive a corresponding response object back and hand it over to
the transoport again for serialization.

Most of these points can be used as hooks. It might, for example, possible to add
logging facilities here or other stuff. The following list of hooks should be
provided:

- Receive the parsed request object before handing it to the backend.
- Receive the processed transport object after receiving it from the backend.

Backend
#######

The extension of a backend works similar to the extension of a transport
object, while the hooks are here always for a special backend and not generic
for any. The sense behind this lies in the backend specific operations that
might be performed inside the extension. The extension will attach to certain
hooks on certain backend classes and will stay completly inactive, if a backend
is in use that it has not attached itself to. This also affects all other
layers of the extension. If a backend is in use that this extension has not
explictly has attached to, it will be deactivated.

Inside the backend implementation it is logical to offer another set of
"BEFORE" and "AFTER" hooks for the existing request classes, as well as hooks
for new ones. Beside that, we implemented an intermediate backend class
ezcWebdavSimpleBackend, which takes over a lot of care from the actual backend
and dispatches to easier protected ones. It is logical to offer special hooks
here, too.





..
   Local Variables:
   mode: rst
   fill-column: 79
   End: 
   vim: et syn=rst tw=79
