<?php
/**
 * File containing the ezcWebdavLockRequestResponseHandler class.
 *
 * @package Webdav
 * @version //autogentag//
 * @copyright Copyright (C) 2005-2008 eZ systems as. All rights reserved.
 * @license http://ez.no/licenses/new_bsd New BSD License
 *
 * @access private
 */
/**
 * Handler class for the LOCK request.
 * 
 * @package Webdav
 * @version //autogen//
 * @copyright Copyright (C) 2005-2008 eZ systems as. All rights reserved.
 * @license http://ez.no/licenses/new_bsd New BSD License
 *
 * @access private
 */
class ezcWebdavLockLockRequestResponseHandler extends ezcWebdavLockRequestResponseHandler
{
    /**
     * Callback if a response was generated for the handled request.
     *
     * If the method {@link receivedRequest()} returned null and the backend
     * has processed the request, the generated $response will be submitted to
     * this method. The handler may perform arbitrary operations, including the
     * manipulation of the $response. Again, this manipulation must happen most
     * carefully, to not influence other plugins
     *
     * The method might return null, to indicate that the submitted response
     * should be send, or a different instance of {@link ezcWebdavResponse} to
     * replace the one generated by the backend. This should only be done in
     * rare cases!
     * 
     * @param ezcWebdavResponse $response 
     * @return ezcWebdavResponse|null
     */
    public function generatedResponse( ezcWebdavResponse $response )
    {
        return null;
    }

    /**
     * Handles LOCK requests (completely).
     *
     * {@inheritdoc}
     *
     * @param ezcWebdavLockRequest $request 
     * @return void
     */
    public function receivedRequest( ezcWebdavRequest $request )
    {
        // Authentication has already taken place here.
        
        // New lock
        if ( $request->lockInfo !== null )
        {
            return $this->acquireLock( $request );
        }
        // Lock refresh
        else
        {
            return $this->refreshLock( $request );
        }
    }

    /**
     * Aquires a new lock.
     *
     * Performs all necessary checks for the lock to be acquired by $request.
     * If any failures occur, either an instance of {@link
     * ezcWebdavErrorResponse} or {@link ezcWebdavMultistatusResponse} is
     * returned. If the lock was acquired successfully, an instance of {@link
     * ezcWebdavLockResponse} is returned.
     * 
     * @param ezcWebdavLockRequest $request 
     * @return ezcWebdavResponse
     */
    protected function acquireLock( ezcWebdavLockRequest $request )
    {
        // Active lock part to be used in PROPPATCH requests and LOCK response
        $lockToken  = $this->tools->generateLockToken( $request );
        $activeLock = $this->tools->generateActiveLock(
            $request,
            $lockToken
        );

        // Generates PROPPATCH requests while checking violations
        $requestGenerator = new ezcWebdavLockLockRequestGenerator(
            $request,
            $activeLock
        );

        // Check violations and collect PROPPATCH requests
        $res = $this->tools->checkViolations(
            array(
                new ezcWebdavLockCheckInfo(
                    $request->requestUri,
                    $request->getHeader( 'Depth' ),
                    $request->getHeader( 'If' ),
                    $request->getHeader( 'Authorization' ),
                    ezcWebdavAuthorizer::ACCESS_WRITE,
                    $requestGenerator
                ),
            )
        );

        if ( $res !== null )
        {
            // 404 -> need to create lock-null resource
            if ( $res instanceof ezcWebdavErrorResponse && $res->status === ezcWebdavResponse::STATUS_404 )
            {
                return $this->createLockNullResource( $request );
            }

            // Other violations -> return error response
            return $res;
        }
        
        $affectedLockDiscovery = null;

        // Send all generated PROPPATCH requests to the backend to update lock information
        foreach ( $requestGenerator->getRequests() as $propPatch )
        {
            // Authorization for lock assignement
            $propPatch->setHeader( 'Authorization', $request->getHeader( 'Authorization' ) );

            $propPatch->validateHeaders();

            $res = ezcWebdavServer::getInstance()->backend->performRequest(
                $propPatch
            );

            if ( !( $res instanceof ezcWebdavPropPatchResponse  ) )
            {
                // An error occured while performing PROPPATCH, very bad thing!
                // @TODO: Should usually cleanup successful patches again!
                return $res;
            }
        }

        return new ezcWebdavLockResponse(
            // Only 1 active lock per resource, so a new response works here
            new ezcWebdavLockDiscoveryProperty( new ArrayObject( array( $activeLock ) ) ),
            $lockToken
        );
    }

    /**
     * Performs a manual request for a lock.
     *
     * Clients may send a lock request without a body and with an If header, to
     * indicate they want to reset the timeout for a lock. This method handles
     * such requests.
     * 
     * @param ezcWebdavLockRequest $request 
     * @return ezcWebdavResponse
     */
    protected function refreshLock( ezcWebdavLockRequest $request )
    {
        if ( ( $ifHeader = $request->getHeader( 'If' ) ) === null )
        {
            return new ezcWebdavErrorResponse(
                ezcWebdavResponse::STATUS_412,
                'If header needs to be provided to refresh a lock.'
            );
        }
        
        $reqGen = new ezcWebdavLockRefreshRequestGenerator(
            $request
        );

        $res = $this->tools->checkViolations(
            array(
                new ezcWebdavLockCheckInfo(
                    $request->requestUri,
                    $request->getHeader( 'Depth' ),
                    $request->getHeader( 'If' ),
                    $request->getHeader( 'Authorization' ),
                    ezcWebdavAuthorizer::ACCESS_WRITE,
                    $reqGen
                ),
            )
        );
        
        if ( $res !== null )
        {
            return $res;
        }

        $reqGen->sendRequests();

        return new ezcWebdavLockResponse(
            $reqGen->getMainLockDiscoveryProperty()
        );
    }

    /**
     * Creates a lock-null resource.
     *
     * In case a LOCK request is issued on a resource, that does not exists, a
     * so-called lock-null resource is created. This resource must support some
     * of the WebDAV requests, but not all. In case an MKCOL or PUT request is
     * issued to such a resource, it is switched to be a real resource. In case
     * the lock is released, all null-lock resources in it are removed.
     * 
     * @param ezcWebdavLockRequest $request 
     * @return ezcWebdavResponse
     */
    protected function createLockNullResource( ezcWebdavLockRequest $request )
    {
        $backend = ezcWebdavServer::getInstance()->backend;

        // Check parent directory for locks and other violations

        $checkRes = $this->tools->checkViolations(
            array(
                new ezcWebdavLockCheckInfo(
                    dirname( $request->requestUri ),
                    ezcWebdavRequest::DEPTH_ZERO,
                    $request->getHeader( 'If' ),
                    $request->getHeader( 'Authorization' ),
                    ezcWebdavAuthorizer::ACCESS_WRITE
                ),
            )
        );

        if ( $checkRes !== null )
        {
            return $checkRes;
        }

        // Create lock null resource

        $putReq = new ezcWebdavPutRequest(
            $request->requestUri,
            ''
        );

        $putRes = $backend->put( $putReq );

        if ( !( $putRes instanceof ezcWebdavPutResponse ) )
        {
            return $this->tools->createLockFailureResponse(
                array( $putRes ),
                new ezcWebdavResource( $request->requestUri )
            );
        }

        // Patch necessary properties
        
        $lockToken         = $this->tools->generateLockToken( $request );
        $lockDiscoveryProp = new ezcWebdavLockDiscoveryProperty(
            new ArrayObject(
                array(
                    $this->tools->generateActiveLock( $request, $lockToken )
                )
            )
        );

        $propPatchReq = new ezcWebdavPropPatchRequest( $request->requestUri );
        $propPatchReq->storage->attach(
            $lockDiscoveryProp,
            ezcWebdavPropPatchRequest::SET
        );
        $propPatchReq->storage->attach(
            new ezcWebdavLockInfoProperty(
                new ArrayObject(
                    array(
                        new ezcWebdavLockTokenInfo(
                            $lockToken,
                            null,
                            new DateTime()
                        ),
                    )
                ),
                // Null resource!
                true
            )
        );

        $propPatchReq->validateHeaders();
        $propPatchRes = $backend->propPatch( $propPatchReq );

        if ( !( $propPatchRes instanceof ezcWebdavPropPatchResponse ) )
        {
            return $this->tools->createLockFailureResponse(
                array( $propPatchRes ),
                new ezcWebdavResource( $request->requestUri )
            );
        }
        
        return new ezcWebdavLockResponse(
            $lockDiscoveryProp,
            $lockToken
        );
    }
}

?>
