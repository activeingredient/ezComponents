eZ publish Enterprise Component: Component, Design
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
:Author: Jan Borsodi
:Revision: $Revision$
:Date: $Date$

Design description
==================

Elements
--------

Elements are the internal types used by the engine to represent the syntax of a
template file. Elements are dividied into several groups and each is explained
in detail.

.. figure:: template_elements.png

   All template elements.

Comments
^^^^^^^^

Comments are text blocks which will be stripped away from the output when the
template is executed. Comments can be standalone spanning an entire tag or
placed inline in template code.
Comments can be used for explaining what or why something is done or to comment
out code which is no longer to be used.

Code comments
`````````````

Code comments are created by starting and ending the tag with an asterix
(\*). Whatever is inside is considered comments for the template code::

  {* Comment text *}
  {* Comments can
      also span
      multiple lines *}

The comment will be read as it is with newlines.

Inline comments
```````````````

Inline comments are created using \/\* and \*\/ or with \/\/. Use the \/\* to
span multiple lines \/\* or the \/\/ to start a comment which continues to the
end of the line::

  {def $a = 1 /*, $b = 2, */, $c = 3 }
  {def $a = 1 //, $b = 2
       , $c = 3}

These comments are usually something you use while developing but isn't left in
after a release is made. If the result after removing the inline comments is an
empty tag the tag itself will be ignored::

  { /* def $a = 1 */ }

Expressions
^^^^^^^^^^^

Expressions are not a real element but rather a way of thinking a combination
of elements. For instance each operator of an operator can be any kind of
element (including new operators) which in the end forms a composition tree.

.. figure:: template_element_composition.png

   Example composition structure.

Builtins
^^^^^^^^

The language comes with several builtin expression for types and structures to
make it easier to use.

Booleans are created with the *true* or *false* names, for instance::

  true
  false
  $a = true

Integers and floats are written as in PHP using::

  1
  1.0

Creating strings is done using single or double quotes, single quotes takes the
characters literally and doesn't allow escaping while the double quotes allows
escaping::

  "a simple string"
  'another simple string'
  "with the escaped characters \"\n\r\t\\"
  'no escaping in here \"\n\r\t\\'

Create arrays and hashes with the syntax::

  array( $v1 [, $v2 ...] )
  array( $k1 => $v1 [, $k2 => $v2 ...] )

Functions
^^^^^^^^^

A function is a piece of reusable code which can be called with parameters.
The function will perform some PHP code and return a value based on the
parameters.  Parameterless functions are also possible.

Functions can either be programmed by implementing the ezcTemplateFunction
interface or mapping them to PHP functions or expressions.

The template language must supply the required functions for the most common
operations. The names should not follow the confusing and inconsistent naming
of PHP functions but provide a clean and easy to understand set (As reference
some of the names in the Qt library have been used, e.g. methods in QString)

Explanation of parameter names.

  $s
    String input
  $v
    Any value
  $a
    An array or hash
  $n
    A number
  $index
    Numeric index
  $len
    Numeric length

Also *l* and *r* is appended to the names to specify left hand side and right
hand side parameters. Left hand side parameters are always considered the
source of the operation.

String manipulation
```````````````````

- *string* str_arg( $s, $v ) ( QString::arg )::

    preg_replace( "/%[0-9]/", $v );

- *string* str_replace( $sl, $index, $len, $sr ) ( QString::replace )::

    substr( $s, 0, $index ) . $sr . substr( $s, $index + $len );

- *string* str_remove( $s, $index, $len ) ( QString::remove )::

    substr( $s, 0, $index ) . substr( $s, $index + $len );

- *string* str_chop( $s, $len ) ( QString::chop )::

    substr( $s, 0, strlen( $len ) - $len );

- *string* str_chop_front( $s, $len ) ( QString::chop )::

    substr( $s, $len );

- *string* str_append( $sl, $sr ) ( QString::append ) ?::

    $sl . $sr

- *string* str_prepend( $sl, $sr ) ( QString::prepend ) ?::

    $sr . $sl

- *string* str_compare( $sl, $sr ) ( QString::compare )::

    strcmp( $sl, $sr );

- *string* str_nat_compare( $sl, $sr )::

    strnatcmp( $sl, $sr );

- *string* str_contains( $sl, $sr ) ( QString::compare )::

    strstr( $sl, $sr )

- *string* str_len( $s ) ( QString::count )::

    strlen( $s )

- *string* str_left( $s, $len ) ( QString::left )::

    substr( $s, 0, $len )

- *string* str_starts_with( $sl, $sr ) ( QString::startsWith )::

    strpos( $sl, $sr ) === 0

- *string* str_right( $s, $len ) ( QString::right )::

    substr( $s, 0, -$len )

- *string* str_ends_with( $sl, $sr ) ( QString::endsWith )::

    strrpos( $sl, $sr ) === ( strlen( $sl ) - 1 )

- *string* str_mid( $s, $index, $len ) ( QString::mid )::

    substr( $s, $index, $len )

- *string* str_at( $s, $index ) ( QString::at )::

    substr( $s, $index, 1 )

- *string* str_fill( $s, $len ) ( QString::fill )::

    str_repeat( $s, $len )

- *string* str_index_of( $sl, $sr [, $index ] ) ( QString::indexOf )::

    strpos( $sl, $sr [, $index ] )

- *string* str_last_index( $sl, $sr [, $index] ) ( QString::lastIndexOf )::

    strrpos( $sl, $sr [, $index ] )

- *string* str_is_empty( $s ) ( QString::isEmpty() )::

    strlen( $s ) === 0

- *string* str_pad_left( $s, $len, $fill ) ( QString::leftJustified() )::

    str_pad( $s, $len, $fill, STR_PAD_LEFT ) === 0

- *string* str_pad_right( $s, $len, $fill ) ( QString::rightJustified() )::

    str_pad( $s, $len, $fill, STR_PAD_RIGHT ) === 0

- *string* str_number( $num, $decimals, $point, $sep )::

    number_format( $num, $decimals, $point, $sep )

- *string* str_trimmed( $s, $chars = false ) ( QString::trimmed )::

    trim( $s, $chars )

- *string* str_trimmed_left( $s, $chars = false )::

    ltrim( $s, $chars )

- *string* str_trimmed_right( $s, $chars = false )::

    rtrim( $s, $chars )

- *string* str_simplified( $s, $chars = false ) ( QString::simplified )::

    preg_replace( "/($s)+/", $chars, "" )

- *array* str_split( $s, $sep, $max = false ) ( QString::split )::

    explode( $s, $sep, $max )

- *string* str_join( $s_list, $sep ) ( QStringList::join )::

    join( $sList, $sep )

- *string* str_printf( $format [...] ) ( QString::sprintf )::

    sprintf( $format [...] )

- *string* str_chr( $ord1 [, $ord2...] )::

    ord( $ord1 ) [ . ord( $ord2 ) ...]

- *string* str_ord( $c )::

    chr( $c )

- *string* str_ord_list( $s )::

    chr( $s[0] ) [ . chr( $s[1] ) ]

- *string* str_upper( $s ) ( QString::toUpper )::

    strtoupper( $s )

- *string* str_lower( $s ) ( QString::toLower )::

    strtolower( $s )

- *string* str_capitalize( $s )::

    ucfirst( $s )

- *string* str_find_replace( $s, $find, $replace, $count )::

    str_replace( $s, $replace, $find, $count )

- *string* str_reverse( $s )::

    strrev( $s )

- *string* str_section( $s, $sep, $start, $end = -1 ) ( QString::section )::

   join( array_slice( split( $s, $sep, $end != -1 ? $end, false ), $start, $end ? $end : false ) )

- *string* str_char_count( $s )::

    strlen( $s )

- *string* str_word_count( $s, $wordsep = false )::

    str_word_count( $s, 0, $wordsep )

- *string* str_paragraph_count( $s )::

    $pos = 0;
    $count = 0;
    while ( preg_match( "/\n\n+/", $s, $m, PREG_OFFSET_CAPTURE, $pos )
    {
        ++$count;
        $pos = $m[0][1];
    }

- *string* str_sentence_count( $s )::

    $pos = 0;
    $count = 0;
    while ( preg_match( "/. /", $s, $m, PREG_OFFSET_CAPTURE, $pos )
    {
        ++$count;
        $pos = $m[0][1];
    }

- *string* str_break( $s, $eol = contextaware, $lbreak = contextaware )::

    str_replace( context_eol_char( $eol ), context_linebreak_char( $eol ), $s )

- *string* str_break_chars( $s, $cbreak )::

    $sNew = '';
    for ( $i = 0; $i < strlen( $s ) - 1; ++$i )
    {
        $sNew .= $s[$i] . $cbreak;
    }
    $sNew .= $s[strlen( $s ) - 1];

- *string* str_wrap( $s, $width, $break, $cut )::

    wordwrap( $s, $width, $break, $cut )

- *string* str_wrap_indent::

   $tmp = wordwrap( $s, $width, $break, $cut )
   $lines = explode( "\n", $tmp );
   $newLines = array();
   foreach ( $lines as $line )
   {
       $newLines[] = $prefix . $line . $suffix;
   }
   return join( "\n", $newLines )

- *string* str_block( $s, $prefix, $suffix )

- *string* str_shorten_right( $s, $max_size )

- *string* str_shorten_mid( $s, $max_size )

- *string* str_shorten_left( $s, $max_size )

- *string* str_crc32( $s )::

    crc32( $s )

- *string* str_md5( $s )::

    md5( $s )

- *string* str_sha1( $s )::

    sha1( $s )

- *string* str_rot13( $s )::

    str_rot13( $s )

Some of the functions are also available as case insensitive versions, they are:

- *string* stri_contains( $sl, $sr ) ( QString::compare )::

    stristr( $sl, $sr ) !== false

- *string* stri_starts_with( $sl, $sr ) ( QString::startsWith )::

    stripos( strtolower( $sl ), strtolower( $sr ) ) === 0

- *string* stri_ends_with( $sl, $sr ) ( QString::endsWith )::

    strripos( $sl, $sr ) === ( strlen( $sl ) - 1 )

- *string* stri_index( $sl, $sr [, $from] ) ( QString::indexOf )::

    stripos( $sl, $sr [, $from ] )

- *string* stri_last_index( $sl, $sr [, $from] ) ( QString::lastIndexOf )::

    strirpos( $sl, $sr [, $from ] )

- *string* stri_find_replace( $s, $find, $replace, $count )::

    str_ireplace( $s, $replace, $find, $count )

- *string* stri_compare( $sl, $sr ) ( QString::compare )::

    strcasecmp( $sl, $sr );

- *string* stri_nat_compare( $sl, $sr )::

    strnatcasecmp( $sl, $sr );


Array manipulation
``````````````````

- *array* array_count( $a ) ( QList::count )::

    count( $a )

- *array* array_contains( $a, $v ) ( QList::contains )::

    in_array( $v, $a )

- *array* array_is_empty( $a ) ( QList::isEmpty() )::

    count( $a ) === 0

- *array* array_index_of( $a, $v, $index = 0 ) ( QList::indexOf() )::

    array_search( $v, $a )

- *array* array_index_exists( $a, $index ) ( QMap::find )::

    array_key_exists( $index, $a )

- *array* array_left( $a, $len )::

    array_slice( $a, 0, $len )

- *array* array_right( $a, $len )::

    array_slice( $a, 0, -$len )

- *array* array_mid( $a, $index, $len ) ( QValueList::mid )::

    array_slice( $a, $index, $len )

- *array* array_insert( $a, $index, $v1 [, $v2 ...] ) ( QList::insert() )::

    array_slice( $a, 0, $index ) + array( $v1 [, $v2 ...] ) + array_slice( $a, $index + value count )

- *array* array_append( $a, $v1 [, $v2 ...] ) ( QList::append() )::

    value count > 1 ? array_push( $a, $v1 [, $v2 ...] ) : $a[] = $v1

- *array* array_prepend( $a, $v1 [, $v2 ...] ) ( QList::prepend )::

    array_unshift( $a, $v1 [, $v2 ...] )

- *array* array_merge( $a1, $a2 [, $a3 ..] ) ( QList::+ )::

    array_merge( $a1, $a2 [, $a3 ...] )

- *array* array_remove( $a, $index, $len = 1 ) ( QList::remove )::

    array_slice( $a, 0, $index ) + array_slice( $a, $index + $len )

- *array* array_remove_first( $a ) ( QList::removeFirst() )::

    array_slice( $a, 1 )

- *array* array_remove_last( $a ) ( QList::removeLast() )::

    array_slice( $a, -1 )

- *array* array_first( $a ) ( QList::first )::

    count( $a ) > 0 ? $a[0] : false

- *array* array_last( $a ) ( QList::last )::

    count( $a ) > 0 ? $a[count( $a ) - 1] : false

- *array* array_replace( $a, $index, $len = 1, $v1 [, $v2 ...] ) ( QList::replace )::

    array_slice( $a, 0, $index ) + array( $v1 [, $v2 ...] ) + array_slice( $a, $index + $len )

- *array* array_swap( $a, $index1, $index2 ) ( QList::swap ) ?::

    $tmp1 = $a[$index1]; $a[$index1] = $a[$index2]; $a[$index2] = $tmp1; unset( $tmp1 );

- *array* array_at( $a, $index ) ( QList::at )::

    $a[$index]

- *array* array_reverse( $a )::

    array_reverse( $a )

- *array* array_diff( $a1, $a2 [, $a3 ...] )::

    array_diff( $a1, $a2 [, $a3 ...] )

- *array* array_insersect( $a1, $a2 [, $a3 ...] )::

    array_intersect( $a1, $a2 [, $a3 ...] )

- *array* array_pad( $a, $len, $fill )::

    array_pad( $a, $len, $fill )

- *array* array_unique( $a )::

    array_unique( $a )

- *array* array_find( $a, $v )::

    array_search( $v, $a )

- *array* array_find_replace( $a, $v, $vNew )::

    $key = array_search( $v, $a ); if ( $key ) $a[$key] = $vNew;

- *array* array_fill_range( $low, $high [, $step] )::

    array_range( $low, $high [, $step] )

- *array* array_sum( $a )::

    array_sum( $a )

- *array* array_extract_by_properties( $a, $pList )::

    array_sum( array_extract_by_properties( $order.items, array( 'price' ) ) )

    becomes

    foreach ( $order->items as $item )
    {
        $list[] = $item->price;
    }
    array_sum( $list )
    unset( $list )

- *array* array_extract_by_keys( $a, $kList )::

    array_sum( array_extract_by_keys( $order.items, array( 'price' ) ) )

    becomes

    foreach ( $order->items as $item )
    {
        $list[] = $item['price'];
    }
    array_sum( $list )
    unset( $list )


Working with associative arrays have some specialized functions

- *array* hash_diff( $a1, $a2 [, $a3 ...] )::

    array_diff_assoc( $a1, $a2 [, $a3 ...] )

- *array* hash_diff_key( $a1, $a2 [, $a3 ...] )::

    array_diff_key( $a1, $a2 [, $a3 ...] )

- *array* hash_intersect( $a1, $a2 [, $a3 ...] )::

    array_intersect_assoc( $a1, $a2 [, $a3 ...] )

- *array* hash_intersect_key( $a1, $a2 [, $a3 ...] )::

    array_intersect( $a1, $a2 [, $a3 ...] )

- *array* hash_keys( $a ) ( QMap::keys )::

    array_keys( $a )

- *array* hash_values( $a )::

    array_values( $a )

- *array* hash_flip( $a )::

    array_flip( $a )


Creating arrays can be done with:

- *array* array_fill( $v, $len ) ( QVector::fill )::

    array_fill( 0, $len, $v )

- *array* array_repeat( $asrc, $len ) ( QVector::fill )::

    $aout = array(); for ( $i = 0; $i < $len; ++$i ) { $aout += $a; }


Sorting of arrays is also possible, this will return the sorted array instead
of manipulating the input expression.

- *array* array_sort( $a [, $flag ] )::

    $tmpa = $a;
    sort( $a );
    return $tmpa;

- *array* array_sort_reverse( $a [, $flag ] )::

    $tmpa = $a;
    rsort( $a );
    return $tmpa;

- *array* hash_sort( $a [, $flag ] )::

    $tmpa = $a;
    asort( $a );
    return $tmpa;

- *array* hash_sort_reverse( $a [, $flag ] )::

    $tmpa = $a;
    arsort( $a );
    return $tmpa;


- *array* hash_sort_keys( $a [, $flag ] )::

    $tmpa = $a;
    ksort( $a );
    return $tmpa;

- *array* hash_sort_keys_reverse( $a [, $flag ] )::

    $tmpa = $a;
    krsort( $a );
    return $tmpa;


Note: The user defined sorting is delibaretely not supported.

Regular expression
``````````````````

- *bool* preg_match( $reg, $s )::

    preg_match( $reg, $s )

- *array* preg_matches( $reg, $s, $flags = false [, $offset] )::

    preg_match( $reg, $s, $matches, $flags [, $offset] )
    return $matches;

- *string* preg_replace( $reg, $replace, $s [, $limit] )::

    preg_replace( $reg, $replace, $s [, $limit] )

- *string* preg_quote( $s [, $delim] )::

    preg_quote( $s [, $delim] )

- *array* preg_split( $reg, $s [, $limit [, $flags] ] )::

    preg_split( $reg, $s [, $limit [, $flags] ] )

- *array* preg_grep( $reg, $a [, $flags] )::

    preg_grep( $reg, $a [, $flags] )


Web manipulation
````````````````

- base64_encode( $s ) ?::

    base64_encode( $s )

- base64_decode( $s ) ?::

    base64_decode( $s )

- url_encode( $url )::

    urlencode( $url )

- url_decode( $url )::

    urldecode( $url )

- url_parameters_build( $params [, $prefix] )::

    http_build_query( $params [, $prefix] )

- *string* url_build( $data (from url_parse) )::

    $url = '';
    if ( $data['scheme'] && $data['host'] )
    {
        $url .= $data['scheme'] . '://';
        if ( $data['user'] )
        {
            $url .= $data['user'];
            if ( $data['pass'] )
                $url .= $data['pass'];
            $url .= '@';
        }
        $url .= $data['host'];
        if ( $data['port'] )
            $url .= ':' . $data['port'];
    }
    $url .= $data['path'];
    if ( $data['query'] )
        $url .= '?' . http_build_query( $data['query']
    if ( $data['fragment'] )
        $url .= '#' . $data['fragment'];

- *hash* url_parse( $url )::

    parse_url( $url )

Handling things like ezurl, ezroot and ezimage is still undecided.

Variables and types
```````````````````

All functions which deals with null will not be included, it does not make
sense to handle this in the template language.

- *bool* is_empty( $v )::

    empty( $v )

- *bool* is_not_empty( $v )::

    !empty( $v )
    
  Might not be needed, using !is_empty should do it.

- *bool* is_array( $v )::

    is_array( $v )

- *bool* is_bool( $v )::

    is_bool( $v )

- *bool* is_float( $v )::

    is_float( $v )

- *bool* is_int( $v )::

    is_int( $v )

- *bool* is_numeric( $v )::

    is_numeric( $v )

- *bool* is_object( $v )::

    is_object( $v ) ?

- *bool* is_class( $v, $class )::

    getclass( $v ) == $class

- *bool* is_scalar( $v )::

    is_scalar( $v )

- *bool* is_string( $v )::

    is_string( $v )

- *bool* is_set( $v )::

    is_set( $v )

- *bool* is_unset( $v )::

    !is_set( $v )

- *string* get_type( $v )::

    gettype( $v )

  Note: Use debug_dump instead?

- *string* get_class( $v )::

    getclass( $v )

  Note: Use debug_dump instead?

Casting to a specific type is done with:

- *string* string( $v )::

    (string)$v

- *int* int( $v )::

    (int)$v

- *float* float( $v )::

    (float)$v

- *mixed* get_constant( $const )::

    if ( defined( $const ) ) return constant( $const );

- *bool* is_constant( $const )::

    return defined( $const )


Arithmetics
```````````

- max( $v1 [, $v2 ...] )::

    max( $v1 [, $v2 ...] )

- min( $v1 [, $v2 ...] )::

    min( $v1 [, $v2 ...] )

- abs( $v )::

    abs( $v )

- ceil( $v )::

    ceil( $v )

- floor( $v )::

    floor( $v )

- round( $v )::

    round( $v )

- sqrt( $v )::

    sqrt( $v )

- exp( $arg )::

    exp( $arg )

- pow( $base, $exp )::

    pow( $base, $exp )

- log( $arg, $base )::

    log( $arg, $base )

- log10( $arg )::

    log10( $arg )

- float_mod( $v )::

    fmod( $v )

- rand( $min, $max )::

    mt_rand( $min, $max )

- pi()::

    pi()

- is_finite( $v )::

    is_finite( $v )

- is_infinite( $v )::

    is_infinite( $v )

- is_nan( $v )::

    is_nan( $v )

- bin_to_dec( $s )::

    bindec( $s )

- hex_to_dec( $s )::

    hexdec( $s )

- oct_to_dec( $s )::

    octdec( $s )

- dec_to_bin( $v )::

    decbin( $v )

- dec_to_hex( $v )::

    dechex( $v )

- dec_to_oct( $v )::

    decoct( $v )

- dec_to_roman( $v )::

    custom code

- format_si( $v, $unit [, $prefix ] )::

    custom code

Trigonometry
````````````

This is deliberately not supported.


Boolean logic
`````````````

Boolean is handled using `builtins`_ and `operators`_.

Control flow
````````````

Control flow allows for quick choices of one expression or the other and can be
nested as many times as needed.

- mixed eval_or( expr1 [, expr2 ...] )

  Evaluates one expression at a time until one has a *"true"* value, in which
  case that value is returned and the rest is ignored. If all values are
  *"false"* it returns *false*.

  Equivalent PHP code::

    $c1 = eval( $expr1 )
    if ( $c1 )
      return $c1;
    $c2 = eval( $expr2 )
    if ( $c2 )
      return $c2;
    ...
    return false

- mixed eval_and( expr1 [, expr2 ...] )

  Evaluates one expression at a time until one has a *"false"* value, in which
  case that value is returned and the rest is ignored. If all values are
  *"true"* it returns *true*.

  Equivalent PHP code::

    $c1 = eval( $expr1 )
    if ( !$c1 )
      return $c1;
    $c2 = eval( $expr2 )
    if ( !$2 )
      return $c2;
    ...
    return true

- mixed eval_first_set( expr1 [, expr2 ...] )

  Examines one expression at a time until all elements in the expression
  exists, in which case it evaluates the expression and returns the value.

  Equivalent PHP code::

    if ( is_set( $expr1 ) )
    {
      return eval( $expr1 )
    }
    if ( is_set( $expr2 ) )
    {
      return eval( $expr2 )
    }
    ...
    return false;

- mixed eval_index( $n, expr1 [, expr2 ...] )

  Uses the first parameter as the lookup value for the following expressions,
  that means if 0 is passed it will find the first (0th) expression, evaluate
  it and return the value.

  Equivalent PHP code::

    if ( $n == 0 )
        eval( expr1 )
    else if ( $n == 1 )
        eval( $expr2 )
    ...

- mixed eval_if( $c, expr1, expr2 )::

    $c ? return eval( $expr1 ) : return eval( $expr2 )

- mixed eval_cond( $c1 => expr1 [, $c2 => expr2 ] [, def_expr ] )::

    if ( $c1 )
        return eval( $expr1 );
    else if ( $c2 )
        return eval( $expr2 );
    else
        return eval( $def_expr );

- string eval_template( $tpl, $outfile )

  Evaluates the references template file $tpl and stores the result in the text
  file $outfile. The full path to the file is returned which can be used in the
  template output. If the output file already exists it will not execute the
  template file again but reuse the file.

  An example::

    @import {eval_template( "design.css.tpl", "design.css" )}

Debugging
`````````

- debug_dump( $v ) -> use reflection to figure out properties etc.
  (Replaces attribute operator)

  Should display the structure of the value::

    if ( is_object( $v ) )
      // dump properties and their values
    else
      var_export( $v, true );


Operators
^^^^^^^^^

Operators are part of an expression and can modify the value or transform it
into another value. Examples of operators are adding two numbers together (+)
or checking for equality (==).  Operators takes one, two or three operands
(called unary, binary and terniary operators).

The operator precedence is as follows (some are missing):

===============  ====================
Associativity    Operators
===============  ====================
right            [ .(left)
non-associative  ++ --
non-associative  ! - instanceof
left             \* / %
left             \+ \- .
non-associative  < <= > >=
non-associative  == != === !==
left             &&
left             ||
left             ? :
right            = += -= \*= /= .= %=
===============  ====================

.. figure:: template_operators.png

   Some of the operator classes.

Arithmetic operators
````````````````````

The arithmetic operators can be used on all expression which returns a
numerical value (integer or float).

==============  ===========
Negation        -$o
Addition        $ol + $or
Subtraction     $ol - $or
Multiplication  $ol * $or
Division        $ol / $or
Modulus         $ol % $or
==============  ===========


Assignment operator
```````````````````

The assignment operator can be used to assign the value of an expression to a
variable or an entry in an array.

==========  =========
Assignment  $ol = $or
==========  =========

Note: Assignment is only allowed with some functions and blocks

See also `Combined operators`_

Combined operators
``````````````````

==============  ============
Addition        $ol += $or
Subtraction     $ol \-= $or
Multiplication  $ol \*= $or
Division        $ol /= $or
Modulus         $ol %= $or
Concat          $ol .= $or
==============  ============

Comparison operators
````````````````````

=====================  ============
Equal                  $ol == $or
Identical              $ol === $or
Not equal              $ol != $or
Not identical          $ol !== $or
Less than              $ol < $or
Greater than           $ol > $or
Less than or equal     $ol <= $or
Greater than or equal  $ol >= $or
=====================  ============

Increment/decrement operators
`````````````````````````````

==============  ====
Pre increment   ++$o
Pre decrement   --$o
Post increment  $o++
Post decrement  $o--
==============  ====

Logical operators
`````````````````

===  ==========
Not  ! $o
And  $ol && $or
Or   $ol || $or
===  ==========

Flow operator
`````````````
============  ===================
If/then/else  $if ? $then : $else
============  ===================

String operators
````````````````

=============  =========
Concatenation  $ol . $or
Substring      $ol[$or]
=============  =========

See also `Combined operators`_


Array operators
```````````````

=====================  ============
Equal                  $ol == $or
Identical              $ol === $or
Not equal              $ol != $or
Not identical          $ol !== $or
Union                  $ol + $or
Key value              $ol[$or]
Append                 $ol[] = $or
=====================  ============

See also `Combined operators`_

Object operators
````````````````

=====================  ===========
Equal                  $ol == $or
Identical              $ol === $or
Not equal              $ol != $or
Not identical          $ol !== $or
Property lookup        $ol.$or
=====================  ===========

Modifiers
^^^^^^^^^

Note: This is probably skipped, conflicts with the rest of the syntax

Blocks
^^^^^^

Blocks are nested structure which performs a given operation on their children.
For instance it can execute the children and then transform the text result
into something else.

.. figure:: template_blocks.png

   Some of the block classes.

Curly braces
````````````

Since the curly braces are used for the invocation of the template syntax they
cannot be used directly in plain text anymore. To get around this you can
escape the brace with a backslash (\)::

  function code()
  \{
  \}

It is also possible to use the specialized ldelim and rdelim blocks to output
them::

  function code()
  {ldelim}
  {rdelim}

Lastly it can also be placed inside a text string::

  function code()
  {"{"}
  {"}"}

Literal text
````````````

If you want to enter lots of code or text which should not be processed by the
template language you can place the code inside *literal* blocks. Any text
within this block is read as it is (even back slashes) until a {/literal} is
reached::

  {literal}
  function code()
  {
  }
  {/literal}

Text manipulation
`````````````````

- block start/block end

  Captures the output of the child elements and performs wrapping, indentation
  and end-of-line style on the result. This can be used to generate lots of
  text with template code and then wrap it into a readable text format::

    {block start [wrap column] [indent prefix] [eol suffix]}
    {block end}

  Parameters:

  - wrap - Which column to wrap at, if not supplied the current context wrap is
    used.
  - indent - A text piece to indent each line with (after wrap), this will be
    appended to any existing indent text.
  - eol - A text piece to replace the newline character for each line (after
    wrap).

- table/tr/th/td

  A set of blocks to easy the generation of plain text tables::

    {table}
    {tr}
      {th}Header1{/th}
      {th}Header2{/th}
    {/tr}
    {tr}
      {td}Element1{/td}
      {td}Element2{/td}
    {/tr}
    {tr}
      {td}Element3{/td}
      {td}Element4{/td}
    {/tr}
    {/table}

- matrix/md/mh

  Easy generation of plain text matrices::

    {matrix 3 by 3}
    {mh}X{/mh}
    {mh}Y{/mh}
    {mh}Z{/mh}
    {md}1{/md}
    {md}2{/md}
    {md}3{/md}
    {md}4{/md}
    {md}5{/md}
    {md}6{/md}
    {md}7{/md}
    {md}8{/md}
    {md}9{/md}
    {/matrix}

- cleanup (XML/XHTML only)

  Renders the child blocks and cleans up excess whitespace from the output to
  reduce whitespace which is only present for being human readable. This is
  something that is done once a project is finished to reduce bandwidth.

  Cleanup blocks can be turned on or off globally to aid in development of
  templates::

    {cleanup}
    <p>

      This contains quite
      a lot of

    unneccesary whitespace.
    </p>
    {/cleanup}

- tidy (XML/XHTML only)

  Renders the child blocks and then tries to rearrange the XML/XHTML structure
  to be more readable. This can be used while developing to make it clearer
  where errors occur in XML/XHTML output::

    {tidy}
    ....
    {/tidy}

User interface
``````````````

- display

  Displays a widget using its run-time display method::

    {display $widget [as view] [context string]}

  Parameters:

  - view - The specific view to display the widget in, if not supplied widget
    should pick a suitable default.
  - context - The current context to render in, e.g. text/plain or HTML. If not
    supplied the current context is used.

- render

  Renders the specified widget as Op-Codes, this can be used to have widget
  components such as buttons and edit fields but not have the run-time overhead
  of using real PHP objects::

    {render <widget> [as view] [context string] [parameters...]}

    {render button label="OK"}
    {render line-edit text="Default text..."}
    {render content-view as line nodeId 5}

  Parameters:

  - view - The specific view to display the widget in, if not supplied widget
    should pick a suitable default.
  - context - The current context to render in, e.g. text/plain or HTML. If not
    supplied the current context is used.

  The rest of the parameters are passed on to the widget. If there is a
  mismatch between parameter name, their types or content it will generate an
  exception.


Control structures
^^^^^^^^^^^^^^^^^^

Control structures are elements which help you control the flow of the code,
either by doing conditional statements or by repeating certain actions.
Control structures can exist both as Blocks and inline code.

.. figure:: template_control_structures.png

   Some of the control structure classes.

Control structures for looping are:

- foreach

- for

- while

- do/while

Control structures for code flow are:

- if/elseif/else

- switch/case

- include

  Executes the external template file and appends the output of it to the
  current text output.

- embed

  Inlines the code from the external template as if it was local code. The code
  will have access to all the variables of the current stack.

- return ?

- break

  Breaks out of loops.
  Used outside a loop will cause an exception.

- continue

  Continues to next iteration in loop and processes the sequence.
  Used outside a loop will cause an exception.

- skip

  Continues to next iteration in loop and does not process the sequence.
  Used outside a loop will cause an exception.

- delimiter

  Piece of code which is executed at given iterations, e.g. every other
  iteration.
  Used outside a loop will cause an exception.

- once

  Execute child elements only once.

Other structures:

- def, undef

- set

Not decided yet:
default, cache-block, tool_bar, menu

Counters
````````

- counter

  Starts a counter at a given value which is increased at given steps. The
  counter can be output and increased automatically. Also counters can be
  stacked to start sub counts for a given period and then continue on the
  previous count later on, the current counter stack level is also available
  for output (starts at 1). If you need multiple separate counters the *name*
  parameter can be used or it can be assigned an object.

  Syntax::

    {counter start [$start] [step $step] [name $name | as $object]}
    {counter stop [name $name | $object]}
    {counter [name $name]}
    {counter level [name $name]}

  Counting from 0::
 
    {counter start 0}
    {counter}
    {counter}
    {counter stop 0}

  Counting from 1 and intervals of 2::

    {counter start 1 step 2}
    {counter}
    {counter}
    {counter stop}

  Counting headers::

    {counter start 1}
    <h{counter level}>{counter} Header</h{counter level}>
    ...
    <h{counter level}>{counter} Header</h{counter level}>
      {counter start 1}
      <h{counter level}>{counter} Header</h{counter level}>
      ...
      <h{counter level}>{counter} Header</h{counter level}>

  Using objects::

    {counter start 1 as $c}
    {$c.value}
    {$c.level}
    {counter stop $c}

- sequence

  Similar to *counter* but will go trough a given sequence array over and over
  again.

  Syntax::

    {sequence start array() [name $name | as $object]}
    {sequence stop [name $name | $object]}
    {sequence restart [name $name]}
    {sequence [name $name]}
    {sequence level [name $name]}

  Sequences are typically used to generate tables with even/odd colors::
 
    {sequence start array( 'red', 'blue' )}
    <table>
    <tr class="{sequence}">...</tr>
    <tr class="{sequence}">...</tr>
    <tr class="{sequence}">...</tr>
    <tr class="{sequence}">...</tr>
    {sequence stop}

  Using objects::

    {sequence start 1 as $s}
    {$s.value}
    {$s.level}
    {sequence stop $s}

Widgets
^^^^^^^

Widgets are reusable user interface objects which can be queried for
information or can be called to display itself in a given way (e.g. using
another template). The widget encapsulates much of the information you would
normally pass as multiple variables and allows extensions to extend some of the
functionality it handles.

.. figure:: template_widget.png

   Widget interface and their supporting classes.

A widget consists of:

- id

  A unique name for the widget, the component/module name should be part of
  this to make it really unique. This is used to identify widgets in use.
  This id can also be used as HTML id for CSS markup and Javascript usage.


- class

  A classification for the widget which can tell what kind of widget it is,
  e.g. push-button or line-edit. Multiple widget classes can exist for one
  *class* allowing for specialization.

  This name is used for fetching widgets dynamically.

- name

  A name which can be displayed to the end user.

- tooltip

  A short description of the widget which can be placed in the HTML.

- whatsThis

  Description of the widget, what it does and how to use it. Can be shown as
  help text or popped up by Javascript code.

- properties

  Widgets are PHP objects so properties are accessed as any other object.

- enabled

  Controls if the widget can be used or not, this can be used to turn off
  certain elements of the page when for instance editing is active.

- hidden

  Whether the widget is to be shown at all or not. If hidden the widget cannot
  display itself anymore.

- sizeHint

  Controls how the widget wants to size itself. e.g. to use as much space as
  possible. This information can be tied together with CSS to get the correct
  display.

- layout

  Controls how to render itself, e.g. to choose the basic CSS layout (not
  colors).

- control

  Can return Javascript for controlling the widget dynamically.

- signals/slots

  Signals the widget can emit, e.g. when the widget is displayed it can send a
  signal about it which can be connected to other widgets or objects.
  Also slots for signals to connect to.

- files

  A list of files involved in the making of the widgets, this includes PHP
  code, template files, CSS files, images and settings.

- parent

  The widget which is the parent of the current one.

- children

  A list of child widgets the current one is composed of.

Also all widgets supports events. Events are the communication method between
the webbrowser and the widgets. Events are generated from the input parameters
(path, request method and request parameters) and passed to a specific widget.
The same events can also be triggered by Javascript code for dynamic behaviour
(AJAX), in this case the event will trigger an event response which can be read
by the JS code.


Examples of what can be conceived as widgets (taken from eZ publish 3.x):

- The tree structure menu in the admin interface.

- The display of a content object in the admin interface consists of several
  widgets, one of them is for instance the child listing.

- The navigator (google) used in most lists.

- The left and right toolbar, these again contains sub-widgets.

- The login/user box on the right.

- Each datatype in the edit field or display field of content objects.

- Smaller UI elements like buttons and edit fields can be widgets, might be too
  much overhead?


The benefits of using widgets are:

- All parts related to the widgets is encapsulated in one place. Figuring out
  what files belongs to a widget is easy.

- Widgets are easily reusable meaning you can build interfaces quite quickly.

- The properties of a widget makes it easy to configure, it is very clear what
  each property controls. No longer does one have to figure out which variables
  to pass on to an included template file.

- No more need for attribute_view_gui, attribute_edit_gui etc. The widget knows
  how to display itself.

- Widgets are classes so they can be extended in PHP code to give them more
  functionality.

- Widgets can be combined with dynamic Javascript code (e.g. AJAX) to change
  them dynamically or fetch them on demand.

- Can in many cases replace fetch() calls.

- Widgets can be registered globally in the system so one can know what is
  available for usage. A admin interface can be provided for examining
  widgets.
  
- Fetching HTTP POST/GET variables and other processing can be done by PHP
  code instead of in templates.

Questions:

1. Should classes like eZContentObjectTreeNode be a widget or should it return
   a widget.

   Being a widget::

     {display $node}

   Returning a widget::

     {display $node.widget}

   Keeping the widget separate is generally a good idea code wise, also this
   will make it easier to override the widget returned by a custom made one.


Output handling
---------------

Output handling is done by append the text result to the current execution
object. Washing of the output depends on the current output context, for
instance it can add additional HTML entity escaping.
Since some strings from functions or properties might return HTML it needs
ways to detect this and disable output washing.

Note: The output from print, echo can be caught if it is desired, e.g. when
executing external PHP scripts.

.. figure:: template_context.png

   The default context classes and the interface.

Type hinting
------------

It must be possible to give type hints to the template system for the variables
and parameters. This can be used by the optimizer to further optimize usage on
variables, e.g. operator usage and function calls.

Op-Codes
--------

The Op-Codes are the result from the transformation of template elements. These
Op-Codes reflect the basic building blocks of PHP code and is highly structured
which allows for easy traversal and transformation.
The Op-Codes can be optimized to reduce the code needed for one template and
then generated into PHP code as text.

The Op-Code structure will be cached on disk before elements are inlined and
the Op-Codes are optimized. This means that the source code for one inlined
element can be updated by recreating the Op-Code structure for this element and
then inlining and optimizing it again.

Design keys
-----------

All PHP objects can return information on design keys to use by implementing
the ezcTemplateDesignkey interface. The object must return a hash array with
the key names and values. A value is either a string or an array of strings.

These design keys are used to determine which actual template file to fetch
(only for some resources).

Design keys are stacked for templates and subtemplates, this means that they
will be inherited to sub-includes unless they are overriden. Once an include is
finished the old design keys are restored.

Execution
---------

The execution of a template file consists of several steps many which can
shortcut under some conditions. The end result is always the execution of a
generated PHP file which consists of code made from the template.

.. figure:: template_execution.png

   Activities in executing a template.

Loading contents
^^^^^^^^^^^^^^^^

.. figure:: template_execution_content_load.png

   Loading the template contents as plain text into source.

Transforming elements
^^^^^^^^^^^^^^^^^^^^^

.. figure:: template_execution_element_transformation.png

   Turning elements into PHP structures.

Generating code
^^^^^^^^^^^^^^^

.. figure:: template_execution_generate_php.png

   Generating PHP code.

Variables
---------

All template variables will be created as normal PHP variables in the compiled
code. This greatly increases the speed of the execution and makes the system
easier to debug. The name of the PHP variable will not match the template name,
the major reason being that some reserved names might clash with the user
defined ones.

Reserved variables
^^^^^^^^^^^^^^^^^^

The template system will use some PHP variables for keeping track of execution
states, these variables must be registered in the template system as being
reserved and used by the variable name generator.


Main classes
------------

.. figure:: template.png

   Main classes for the template engine.

Public classes
--------------

To make it easier for 3rd party developers to access or enhance the template
engine they must make sure they only relate to what is defined as public
classes.

.. figure:: template_public.png

   Publicly available classes.

Normal usage
^^^^^^^^^^^^

The most common way to use the template engine is to execute template files and
get the resulting output text. This involves creating an *ezcTemplate* object
and setting the correct output context.

Extending the engine
^^^^^^^^^^^^^^^^^^^^

There are many ways to extend what the engine is capable of. This can be to
generate a new context for handling the output, creating new elements
(e.g. functions) or providing new specialized widgets.

Guidelines
==========


Algorithms
==========


Data structures
===============

.. figure:: template_structures.png

   The various internal classes used to execute code.



..
   Local Variables:
   mode: rst
   fill-column: 79
   End:
   vim: et syn=rst tw=79
